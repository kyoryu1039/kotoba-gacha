<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1">
<title>KOTOBA-BATTLE | 対戦 v7.16</title>
<style>
:root{
  /* クリーム背景＆高コントラスト */
  --bg:#fff7e9;
  --panel:#0f1633;--panel2:#0e1530;--border:#1d2b52;--text:#eaf2ff;

  --ally:#27b1ff;--ally2:#69d3ff;--enemy:#ff6b7a;--enemy2:#ff9aa5;
  --hp:#63ff8c;--hpBack:#0f2a1c;--gauge:#ffe066;--gaugeBack:#31260a;
  --shadow:0 18px 44px rgba(0,0,0,.20);

  /* タイプ色（不透明寄りにして視認性UP） */
  --t-ジオ:#7aa0ff;        --tbg-ジオ:linear-gradient(180deg,#13234f 0%, rgba(122,160,255,.58) 100%);
  --t-アニマル:#34d790;    --tbg-アニマル:linear-gradient(180deg,#0f2c2a 0%, rgba(52,215,144,.58) 100%);
  --t-フード:#ffbf4d;      --tbg-フード:linear-gradient(180deg,#2b2312 0%, rgba(255,191,77,.58) 100%);
  --t-コンセプト:#b68cff;  --tbg-コンセプト:linear-gradient(180deg,#271d45 0%, rgba(182,140,255,.58) 100%);
  --t-サイエンス:#2dd6ff;  --tbg-サイエンス:linear-gradient(180deg,#0c2638 0%, rgba(45,214,255,.58) 100%);
  --t-ヒストリー:#ff7a9a; --tbg-ヒストリー:linear-gradient(180deg,#2b1522 0%, rgba(255,122,154,.58) 100%);
  --t-ヒューマン:#5ff3d3;  --tbg-ヒューマン:linear-gradient(180deg,#143035 0%, rgba(95,243,211,.58) 100%);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0}
body{background:var(--bg);color:var(--text);font-family:system-ui,"Noto Sans JP",sans-serif;overflow-x:hidden}
.container{max-width:1024px;margin:0 auto;padding:10px}
.card{background:var(--panel);border:1px solid var(--border);border-radius:16px;box-shadow:var(--shadow)}
.card h2{margin:0;padding:12px 16px;border-bottom:1px solid var(--border);font-size:18px}
.card .body{padding:12px}
.note{color:#c9d7ff;font-size:12px}

/* 編成 */
#setup{display:grid;gap:12px}
#teamGrid{display:grid;gap:10px}
@media(min-width:720px){#teamGrid{grid-template-columns:1fr 1fr}}
.slot{display:flex;gap:8px;align-items:center}
.pill{display:inline-grid;place-items:center;width:28px;height:28px;border-radius:8px;background:#0b1430;border:1px solid #2b3a70;color:#cfe2ff;font-weight:800}
.slot select{flex:1;background:#0b1430;border:1px solid #25366b;color:#eaf2ff;padding:10px;border-radius:12px}
.statsHead{font-weight:900;margin:2px 0 6px}
#statsGrid{display:grid;gap:12px}
@media(min-width:720px){#statsGrid{grid-template-columns:1fr 1fr}}
.statsCol{display:grid;grid-template-rows:repeat(3,auto);gap:10px}
.setupMini{border:2px solid #203060;border-radius:12px;padding:10px;position:relative}
.setupMini[data-type="ジオ"]{background:var(--tbg-ジオ);box-shadow:0 0 0 3px var(--t-ジオ) inset}
.setupMini[data-type="アニマル"]{background:var(--tbg-アニマル);box-shadow:0 0 0 3px var(--t-アニマル) inset}
.setupMini[data-type="フード"]{background:var(--tbg-フード);box-shadow:0 0 0 3px var(--t-フード) inset}
.setupMini[data-type="コンセプト"]{background:var(--tbg-コンセプト);box-shadow:0 0 0 3px var(--t-コンセプト) inset}
.setupMini[data-type="サイエンス"]{background:var(--tbg-サイエンス);box-shadow:0 0 0 3px var(--t-サイエンス) inset}
.setupMini[data-type="ヒストリー"]{background:var(--tbg-ヒストリー);box-shadow:0 0 0 3px var(--t-ヒストリー) inset}
.setupMini[data-type="ヒューマン"]{background:var(--tbg-ヒューマン);box-shadow:0 0 0 3px var(--t-ヒューマン) inset}
.setupMini .head{display:flex;justify-content:space-between;font-weight:800}

/* 共通バー（相対表示：HP800/攻120/防120/回避20 を基準） */
.barLine{display:flex;align-items:center;gap:10px;margin-top:6px}
.barBox{flex:1;min-width:140px;height:16px;background:#0e1b31;border:1px solid #2a3a6b;border-radius:8px;overflow:hidden}
.barFill{height:100%;background:var(--hp)}
.val{font-size:12px;color:#cfe2ff;width:96px;text-align:right}

/* 切替 */
.inSetup{display:block}.inBattle{display:none}
.battleMode .inSetup{display:none}.battleMode .inBattle{display:block}

/* バトル */
.arena{min-height:calc(100vh - 120px);display:grid;grid-template-rows:auto auto auto auto;gap:12px}
.vsrow{display:grid;grid-template-columns:1fr 1fr;gap:12px}

/* ユニットカード */
.unit{border:1px solid #243567;border-radius:14px;padding:12px;position:relative;min-height:220px}
.unit[data-type="ジオ"]{background:var(--tbg-ジオ)} .unit[data-type="アニマル"]{background:var(--tbg-アニマル)}
.unit[data-type="フード"]{background:var(--tbg-フード)} .unit[data-type="コンセプト"]{background:var(--tbg-コンセプト)}
.unit[data-type="サイエンス"]{background:var(--tbg-サイエンス)} .unit[data-type="ヒストリー"]{background:var(--tbg-ヒストリー)}
.unit[data-type="ヒューマン"]{background:var(--tbg-ヒューマン)}
.owner{position:absolute;top:8px;left:8px;font-size:12px;padding:3px 9px;border-radius:999px;border:1px solid #2d3a70;background:#0b1635d8}
.owner.ally{color:var(--ally)} .owner.enemy{color:var(--enemy)}
.nameRow{display:flex;justify-content:space-between;align-items:center;margin-top:18px}
.badge{font-size:12px;background:#0d1630;border:1px solid #2b3a70;padding:2px 8px;border-radius:999px}
.meta{font-size:12px;color:#cfe2ff;margin-top:6px}

/* HPゲージ（上段・長め） */
.hpRow{display:flex;align-items:center;gap:10px;margin-top:8px}
.hpBox{flex:1;height:22px;background:var(--hpBack);border-radius:11px;overflow:hidden}
.hpFill{height:100%;background:var(--hp);transition:width .6s ease}
.hpNum{font-size:13px;width:180px;text-align:right}

/* 必殺ゲージ */
.gaugeWrap{display:flex;align-items:center;gap:8px;margin-top:6px}
.gLabel{font-size:12px;color:#ffeaa7}
.gauge{display:flex;gap:4px}
.pip{width:16px;height:12px;background:var(--gaugeBack);border:1px solid #5a480c;border-radius:3px;opacity:.7}
.pip.on{background:var(--gauge);opacity:1}
.readyPulse{animation:pulse 1.2s infinite}
@keyframes pulse{0%{box-shadow:0 0 0 0 rgba(255,224,102,.55)}70%{box-shadow:0 0 0 14px rgba(255,224,102,0)}100%{box-shadow:0 0 0 0 rgba(255,224,102,0)}}
.btnReady{animation:pulse 1.2s infinite}

/* 技と相性 */
.skillWrap{display:grid;grid-template-columns:1fr;gap:8px;margin-top:8px}
.skillBox{border:1px solid #2c3a69;border-radius:12px;background:#0c1633;padding:10px}
.skillTitle{font-weight:900;display:flex;align-items:center;gap:6px}
.skillDesc{margin-top:4px;font-size:12px;color:#cfe2ff}
.affinityBox{border:1px solid #2c3a69;border-radius:12px;background:#0b1530;padding:8px;font-size:12px}

/* 相対ステータス（長め） */
.statBars{margin-top:8px}
.statBars .barBox{height:16px}
.statBars .barLine .val{width:110px}

/* パッド */
.pad{border:1px solid #233562;border-radius:14px;background:linear-gradient(180deg,#0d1530,#0b1428);padding:10px}
.padInner{position:relative;width:min(520px,96vw);height:210px;margin:0 auto}
.rps{position:absolute;display:grid;place-items:center;width:92px;height:92px;border-radius:999px;border:none;color:#061225;cursor:pointer}
.rps .emo{font-size:34px}.rps .lbl{font-size:12px;margin-top:2px;font-weight:800}
.rps.g{left:8%;top:8%;background:linear-gradient(180deg,#ffdfde,#ff8b8b)}
.rps.c{right:8%;top:8%;background:linear-gradient(180deg,#e0e8ff,#8bb1ff)}
.rps.p{left:50%;transform:translateX(-50%);bottom:26%;background:linear-gradient(180deg,#defae5,#8bffb5)}
.switchBtn{position:absolute;right:4%;bottom:6%;width:132px;height:56px;border-radius:14px;background:linear-gradient(90deg,#ffd89b,#fda085);border:none;color:#26110b;font-weight:900;cursor:pointer}
.spToggle{position:absolute;left:4%;bottom:6%;width:132px;height:56px;border-radius:14px;background:#0e1530;border:2px solid #f2c94c;color:#f2c94c;font-weight:900;transition:.2s;cursor:pointer}
.spToggle.on{background:linear-gradient(90deg,#ffe066,#ffcf33)!important;color:#2a1700!important;border-color:#ffcf33!important}
.spToggle:disabled{opacity:.45;filter:grayscale(.5)}

/* ボックス（控え） */
#benchWrap{margin-top:2px}
.benchTitle{font-weight:900;margin:6px 4px 4px}
#boxGrid{display:grid;gap:10px}
@media(min-width:720px){#boxGrid{grid-template-columns:1fr 1fr}}
.boxCol{background:var(--panel2);border:1px solid #233562;border-radius:12px;padding:8px}
#sixA,#sixB{display:grid;grid-template-columns:1fr;gap:10px}
.mini{border:1px solid #1a2b54;border-radius:12px;padding:8px;cursor:pointer;position:relative}
.mini[data-type="ジオ"]{background:var(--tbg-ジオ)} .mini[data-type="アニマル"]{background:var(--tbg-アニマル)}
.mini[data-type="フード"]{background:var(--tbg-フード)} .mini[data-type="コンセプト"]{background:var(--tbg-コンセプト)}
.mini[data-type="サイエンス"]{background:var(--tbg-サイエンス)} .mini[data-type="ヒストリー"]{background:var(--tbg-ヒストリー)}
.mini[data-type="ヒューマン"]{background:var(--tbg-ヒューマン)}
.mini .head{display:flex;justify-content:space-between}
.mini .miniBar{height:11px;background:#11321f;border-radius:6px;overflow:hidden;margin-top:6px}
.mini .miniBar>span{display:block;height:100%;background:var(--hp)}

/* タイマー＆トースト */
.timer{display:flex;justify-content:center;gap:8px;align-items:center;font-weight:900}
.timer .num{font-size:28px}
.toastArea{min-height:56px}
.toast{margin:6px auto 0;max-width:min(96vw,720px);padding:12px 16px;border-radius:14px;background:rgba(12,22,50,.96);border:1px solid #2b3a70;color:#eaf3ff;opacity:0;transform:translateY(8px);transition:.22s ease}
.toast.show{opacity:1;transform:translateY(0)}

/* 攻撃FX */
@keyframes shake{0%,100%{transform:translateX(0)}20%{transform:translateX(-10px)}40%{transform:translateX(8px)}60%{transform:translateX(-6px)}80%{transform:translateX(4px)}}
.shake{animation:shake .5s ease}
.fx-burst{box-shadow:0 0 0 3px rgba(255,224,102,.7),0 0 22px 6px rgba(255,224,102,.25);transition:.2s}

/* 勝敗 */
#result{position:fixed;inset:0;background:rgba(6,10,26,.82);display:none;place-items:center;z-index:40}
#result .box{background:var(--panel);border:1px solid var(--border);border-radius:18px;padding:26px 28px;text-align:center;box-shadow:var(--shadow)}
#result h1{margin:0 0 8px;font-size:40px}
#result p{margin:4px 0 0;color:#cfe2ff}

/* モーダル */
#switchModal,#infoModal{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;place-items:center;z-index:30}
.selCard{cursor:pointer} .selCard.selected{outline:3px solid #ffe066}

/* モバイル密度 */
@media(max-width:600px){
  html{font-size:15px}
  .container{padding:8px}
  .arena{grid-template-rows:auto auto auto auto}
  .padInner{width:96vw;height:180px}
  .rps{width:78px;height:78px}.rps .emo{font-size:30px}
  .switchBtn,.spToggle{width:118px;height:52px}
  #teamGrid{grid-template-columns:1fr}
  .hpNum{width:130px}
}
</style>
</head>
<body>

<!-- ───────── 編成画面 ───────── -->
<div class="container inSetup" id="setup">
  <section class="card">
    <h2>チーム編成（あなた / CPU）</h2>
    <div class="body">
      <div id="teamGrid">
        <div>
          <div class="statsHead" style="color:#27b1ff">あなた</div>
          <div id="teamA"></div>
        </div>
        <div>
          <div class="statsHead" style="color:#ff6b7a">CPU</div>
          <div id="teamB"></div>
        </div>
      </div>
      <div class="row" style="display:flex;gap:10px;align-items:center;margin-top:12px">
        <button id="btnRand" class="ghost">ランダムでチームを編成</button>
        <button id="btnStart" class="primary" style="margin-left:auto">対戦開始</button>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>選択中のステータス</h2>
    <div class="body">
      <div id="statsGrid">
        <div>
          <div class="statsHead" style="color:#27b1ff">あなた</div>
          <div class="statsCol" id="statsA"></div>
        </div>
        <div>
          <div class="statsHead" style="color:#ff6b7a">CPU</div>
          <div class="statsCol" id="statsB"></div>
        </div>
      </div>
    </div>
  </section>
</div>

<!-- ───────── バトル画面 ───────── -->
<div id="battle" class="container inBattle">
  <section class="card">
    <div class="body">
      <div class="arena">
        <div class="vsrow">
          <div id="leftWrap"></div>
          <div id="rightWrap"></div>
        </div>

        <div class="pad">
          <div class="padInner">
            <button class="rps g" id="btnG"><div class="emo">✊</div><div class="lbl">グー</div></button>
            <button class="rps c" id="btnC"><div class="emo">✌️</div><div class="lbl">チョキ</div></button>
            <button class="rps p" id="btnP"><div class="emo">🖐</div><div class="lbl">パー</div></button>
            <button class="switchBtn" id="btnSwitch">🔁 交代</button>
            <button class="spToggle" id="btnSP" disabled>✨ 必殺 OFF</button>
          </div>
        </div>

        <div class="toastArea"><div class="toast" id="toast"></div></div>
        <div class="timer">選択まで <span class="num" id="countNum">15</span> 秒</div>

        <div id="benchWrap">
          <div class="benchTitle">ボックス</div>
          <div id="boxGrid">
            <div class="boxCol">
              <div class="statsHead" style="color:#27b1ff">あなたのボックス</div>
              <div id="sixA"></div>
            </div>
            <div class="boxCol">
              <div class="statsHead" style="color:#ff6b7a">CPUのボックス</div>
              <div id="sixB"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
</div>

<!-- 交代モーダル -->
<div id="switchModal">
  <div class="card" style="min-width:min(92vw,560px)">
    <h2>交代先を選択</h2>
    <div class="body">
      <div id="switchGrid" style="display:grid;grid-template-columns:1fr 1fr;gap:10px"></div>
      <div class="row" style="display:flex;justify-content:space-between;margin-top:10px">
        <div id="swTimer" class="note">自動交代まで 15 秒</div>
        <div>
          <button id="swCancel" class="ghost">キャンセル</button>
          <button id="swDo" class="primary" disabled>交代する</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- 情報モーダル（ボックス詳細） -->
<div id="infoModal"><div class="card" style="min-width:min(92vw,520px)"><h2 id="infoTitle">情報</h2><div class="body" id="infoBody">...</div></div></div>

<!-- 勝敗 -->
<div id="result"><div class="box"><h1 id="resTitle">WIN!</h1><p id="resSub">3秒後に編成へ戻る…</p></div></div>

<script>
(()=>{'use strict';
const $=id=>document.getElementById(id);
const delay=ms=>new Promise(r=>setTimeout(r,ms));

/* トースト（すべて 1.5s + 0.06s×文字数） */
const toastQueue=[]; let toastBusy=false;
function toast(msg){toastQueue.push(String(msg)); if(!toastBusy) runToast();}
function toastDuration(msg){const base=1500, per=60; return Math.min(9000, base + Math.max(0,String(msg).length)*per) + 120;}
async function runToast(){
  toastBusy=true;
  while(toastQueue.length){
    const t=$('toast'), msg=toastQueue.shift(), stay=toastDuration(msg);
    t.textContent=msg; t.classList.add('show'); await delay(stay);
    t.classList.remove('show'); await delay(120);
  }
  toastBusy=false;
}

/* 相対バー最大 */
const MAX={HP:800,ATK:120,DEF:120,EVA:20};

/* 相性リング */
const TYPES_RING=['ヒストリー','ジオ','コンセプト','サイエンス','アニマル','ヒューマン','フード'];
const typeMult=(atk,def)=>{const n=TYPES_RING.length,i=TYPES_RING.indexOf(atk),j=TYPES_RING.indexOf(def);if(i<0||j<0)return 1;const strong=[(i+1)%n,(i+2)%n],weak=[(i-1+n)%n,(i-2+n)%n];if(strong.includes(j))return 1.5;if(weak.includes(j))return 0.67;return 1;};

/* ランク・HP基準 */
const PRANK={S:170,A:165,B:160,C:150,D:145,X:150};
const HP_BASE={S:560,A:540,B:520,C:500,D:480,X:500};

/* 必殺（だ・である調） */
const SKILLS={
 "パラボラアンテナ":["妨害電波","この一撃は2.5倍である。さらに相手の必殺ゲージを0にする。"],
 "ネスカフェアンバサダー":["一杯いかが","通常攻撃のあと、味方全員のHPを60回復する（自分も60）。"],
 "にんじんしりしり":["なんくるないさー","この一撃は1.6倍である。次に受ける致命傷を1回だけHP1で耐える。"],
 "そぼろごはん":["そぼろ乱舞","3連撃で攻撃する（0.75→0.5→0.25倍）。相手を倒したら次の相手にも続く。"],
 "ニシローランドゴリラ":["マウンテンビート","この一撃は1.5倍である。さらに次の2ターンの攻撃が1.3倍になる。"],
 "毛むくじゃら":["ムクジャララ","この一撃は1.4倍である。さらに3ターンのあいだ回避率を60%にする。"],
 "九品仏":["仏の顔も三度まで","この一撃は1.6倍である。さらに3ターンのあいだ受けるダメージを半分にする。"],
 "けんちん汁":["長寿の秘訣","この一撃は1.2倍である。さらにHPを150回復する。"],
 "カムチャッカ半島":["言論統制","相手は4ターンのあいだ控えと交代できない。"],
 "タランチュラ":["言葉狩り","相手はこのターン行動できない。"],
 "ハシビロコウ":["言論統制","相手は4ターンのあいだ控えと交代できない。"],
 "バルサミコ酢":["言論統制","相手は4ターンのあいだ控えと交代できない。"],
 "ピロリ菌":["ゲシュタルト崩壊","次の4ターン、攻撃のたびに33%の確率で自分に100ダメージを受ける。"],
 "トリニダード・トバゴ":["言葉狩り","相手はこのターン行動できない。"],
 "カラメル色素":["ゲシュタルト崩壊","次の4ターン、攻撃のたびに33%の確率で自分に100ダメージを受ける。"],
 "バビロン捕囚":["言論統制","相手は4ターンのあいだ控えと交代できない。"],
 "鳥取砂丘":["ゲシュタルト崩壊","次の4ターン、攻撃のたびに33%の確率で自分に100ダメージを受ける。"],
 "プラシーボ効果":["ゲシュタルト崩壊","次の4ターン、攻撃のたびに33%の確率で自分に100ダメージを受ける。"],
 "渡来人":["文字化け","3ターン後に戦闘不能になる（交代で解除される）。"],
 "さるびあ丸":["言葉狩り","相手はこのターン行動できない。"],
 "ペペロンチーノ":["ゲシュタルト崩壊","次の4ターン、攻撃のたびに33%の確率で自分に100ダメージを受ける。"],
 "ポリプロピレン":["言論統制","相手は4ターンのあいだ控えと交代できない。"],
 "サラエボ事件":["言葉狩り","相手はこのターン行動できない。"],
 "クマンバチ":["言論統制","相手は4ターンのあいだ控えと交代できない。"],
 "県庁所在地":["文字化け","3ターン後に戦闘不能になる（交代で解除される）。"],
 "照り焼きチキン":["言論統制","相手は4ターンのあいだ控えと交代できない。"],
 "ねるねるねるね":["ゲシュタルト崩壊","次の4ターン、攻撃のたびに33%の確率で自分に100ダメージを受ける。"],
 "スルメイカ":["ゲシュタルト崩壊","次の4ターン、攻撃のたびに33%の確率で自分に100ダメージを受ける。"],
 "本質":["鏡文字","相手チームのだれかの必殺をコピーして使う（威力2倍）。"],
 "見える化":["鏡文字","相手チームのだれかの必殺をコピーして使う（威力2倍）。"],
 "自分ごと化":["鏡文字","相手チームのだれかの必殺をコピーして使う（威力2倍）。"],
 "解像度":["鏡文字","相手チームのだれかの必殺をコピーして使う（威力2倍）。"]
};

/* ワード（名前, ランク, タイプ, 読み） */
const WORDS_BASE=[["パラボラアンテナ","S","サイエンス","ぱらぼらあんてな"],["ネスカフェアンバサダー","S","ヒューマン","ねすかふぇあんばさだー"],["にんじんしりしり","A","フード","にんじんしりしり"],["そぼろごはん","A","フード","そぼろごはん"],["ニシローランドゴリラ","A","アニマル","にしろーらんどごりら"],["毛むくじゃら","A","アニマル","けむくじゃら"],["九品仏","A","ジオ","くほんぶつ"],["けんちん汁","A","フード","けんちんじる"],["カムチャッカ半島","B","ジオ","かむちゃっかはんとう"],["タランチュラ","B","アニマル","たらんちゅら"],["ハシビロコウ","B","アニマル","はしびろこう"],["バルサミコ酢","B","フード","ばるさみこす"],["ピロリ菌","B","サイエンス","ぴろりきん"],["トリニダード・トバゴ","B","ジオ","とりにだーどとばご"],["カラメル色素","B","サイエンス","からめるしきそ"],["バビロン捕囚","C","ヒストリー","ばびろんほしゅう"],["鳥取砂丘","C","ジオ","とっとりさきゅう"],["プラシーボ効果","C","サイエンス","ぷらしーぼこうか"],["渡来人","C","ヒューマン","とらいじん"],["さるびあ丸","C","ジオ","さるびあまる"],["ペペロンチーノ","C","フード","ぺぺろんちーの"],["ポリプロピレン","C","サイエンス","ぽりぷろぴれん"],["サラエボ事件","C","ヒストリー","さらえぼじけん"],["クマンバチ","D","アニマル","くまんばち"],["県庁所在地","D","ジオ","けんちょうしょざいち"],["照り焼きチキン","D","フード","てりやきちきん"],["ねるねるねるね","D","フード","ねるねるねるね"],["スルメイカ","D","アニマル","するめいか"],["本質","X","コンセプト","ほんしつ"],["見える化","X","コンセプト","みえるか"],["自分ごと化","X","コンセプト","じぶんごとか"],["解像度","X","コンセプト","かいぞうど"]];

/* ステータス算出 */
const reKanaH=/[ぁ-ゟ]/g,reKanaK=/[゠-ヿー]/g,reKanji=/[一-龥々〆ヵヶ]/g,reSmallK=/[ァィゥェォャュョヮㇰ-ㇿ]/g,reSokuon=/ッ/g,reVoiced=/[ガ-ポヴ]/g,PLosiveEnd=/[ツックキチテトプピペポカタ]$/;
const visualLen=s=>(s||"").replace(/[・\s]/g,"").length; const toKatakana=s=>(s||"").replace(/[ぁ-ん]/g,ch=>String.fromCharCode(ch.charCodeAt(0)+0x60));
function countClass(s){const H=(s.match(reKanaH)||[]).length,K=(s.match(reKanaK)||[]).length,J=(s.match(reKanji)||[]).length,t=H+K+J;return{H,K,J,total:t};}
function calcAttackDefense(name,yomi){let atkP=17.5,defP=17.5;const cls=countClass(name);if(cls.J+cls.K===0){atkP+=12.5;defP+=12.5;}else{const r=cls.K/(cls.J+cls.K);atkP+=25*r;defP+=25*(1-r);}const Lph=yomi.length||1;const d=(yomi.match(reVoiced)||[]).length/Lph,s=(yomi.match(reSokuon)||[]).length/Lph,m=(yomi.match(reSmallK)||[]).length/Lph,e=PLosiveEnd.test(yomi)?1:0;const raw=0.6*d+0.25*(s+m)+0.15*e,L=0.05,U=0.45,ph=Math.max(-1,Math.min(1,((raw-L)/(U-L))*2-1));const atk_ph=20*(0.5+0.5*ph);atkP+=atk_ph;defP+=20-atk_ph;const T=visualLen(name),len=Math.max(-1,Math.min(1,(6-T)/6));const atk_len=20*(0.5+0.5*len);atkP+=atk_len;defP+=20-atk_len;return{atkP,defP,T};}
function calcEvasion(name,T,rank){const cls=countClass(name);const Hratio=cls.total?(cls.H/cls.total):0;const adj=({S:-1,A:-0.5,B:0,C:0.5,D:1,X:0})[rank]??0;let eva=10+8*Hratio-0.5*(T-5)+adj;eva=Math.round(eva*10)/10;return Math.max(5,Math.min(35,eva));}
function makeWordObject([name,rank,type,yomiH]){const y=toKatakana(yomiH||name);const {atkP,defP,T}=calcAttackDefense(name,y);const ATK=Math.round(PRANK[rank]*(atkP/100)),DEF=Math.round(PRANK[rank]*(defP/100)),HP=HP_BASE[rank]+20*(T-5),EVA=calcEvasion(name,T,rank);const [sk,sd]=SKILLS[name]||["—","—"];return {name,rank,type,yomi:y,maxhp:HP,hp:HP,atk:ATK,def:DEF,eva:EVA,skill:sk,skillDesc:sd};}
const getWord=i=>makeWordObject(WORDS_BASE[i]);

/* 状態 */
const state={A:{team:[],i:0,sp:0},B:{team:[],i:0,sp:0},remain:15,timer:null,spOn:false,busy:false,spAnnA:false,spAnnB:false};

/* 表示部品 */
function barRow(label,val,max){const pct=Math.max(0,Math.min(100,Math.round((label==='回避'? (val/MAX.EVA):(val/max))*100)));return `<div class="barLine"><div style="width:76px;font-size:12px;color:#cfe2ff">${label}</div><div class="barBox"><div class="barFill" style="width:${pct}%"></div></div><div class="val">${label==='回避'?val+'%':val}</div></div>`;}
function miniCard(idx){const w=getWord(idx);return `<div class="setupMini" data-type="${w.type}"><div class="head"><div>${w.name}</div><div class="badge">${w.type}</div></div>${barRow('HP',w.maxhp,MAX.HP)}${barRow('攻撃',w.atk,MAX.ATK)}${barRow('防御',w.def,MAX.DEF)}${barRow('回避',w.eva,MAX.EVA)}</div>`;}
function renderMini(side){const root=side==='A'?$('statsA'):$('statsB');root.innerHTML='';for(let i=0;i<3;i++){const idx=Number($(`${side}-${i}`).value)||0;root.innerHTML+=miniCard(idx);}}

function makeTeam(root,side){
  root.innerHTML='';
  for(let i=0;i<3;i++){
    const div=document.createElement('div');div.className='slot';
    const pill=document.createElement('span');pill.className='pill';pill.textContent='#'+(i+1);
    const sel=document.createElement('select');sel.id=`${side}-${i}`;
    WORDS_BASE.forEach((w,idx)=>{const o=document.createElement('option');o.value=idx;o.textContent=`${w[0]} [${w[1]}/${w[2]}]`;sel.append(o);});
    sel.addEventListener('change',()=>{enforceUnique(side);renderMini(side);});
    div.append(pill,sel);root.append(div);
  }
  const picks=uniqueRandom(3,WORDS_BASE.length);picks.forEach((v,i)=>$(`${side}-${i}`).value=v);
  enforceUnique(side);renderMini(side);
}
function uniqueRandom(n,lim){const used=new Set(),arr=[];while(arr.length<n){const i=Math.floor(Math.random()*lim);if(!used.has(i)){used.add(i);arr.push(i)}}return arr;}
function enforceUnique(side){
  const selected=[0,1,2].map(i=>Number($(`${side}-${i}`).value));
  for(let i=0;i<3;i++){const sel=$(`${side}-${i}`);[...sel.options].forEach(opt=>{const v=Number(opt.value);const dup=selected.includes(v)&&v!==Number(sel.value);opt.disabled=dup;});}
}
function collect(side){const arr=[];for(let i=0;i<3;i++){const idx=Number($(`${side}-${i}`).value)||0;arr.push(pack(getWord(idx),side));}return arr;}
const pack=(w,side)=>({...w,side});

/* バトルUI */
function gaugeHtml(sp,tag){const pips=[...Array(6)].map((_,i)=>`<span class="pip ${i<sp?'on':''}"></span>`).join('');const pulse=sp>=6?'readyPulse':'';return `<div class="gaugeWrap"><div class="gLabel">必殺ゲージ</div><div class="gauge ${pulse}" id="g${tag}">${pips}</div></div>`;}
function statBarsHtml(u){return `<div class="statBars">${barRow('HP',u.maxhp,MAX.HP)}${barRow('攻撃',u.atk,MAX.ATK)}${barRow('防御',u.def,MAX.DEF)}${barRow('回避',u.eva,MAX.EVA)}</div>`;}
function cardHtml(u,role,opp){
  const aff=typeMult(u.type,opp.type);
  const affText=aff===1.5?'相性 x1.5（抜群）':aff===0.67?'相性 x0.67（いまいち）':'相性 x1.0（等倍）';
  const sp=role==='ally'?state.A.sp:state.B.sp;const tag=role==='ally'?'A':'B';
  const owner=role==='ally'?'あなた':'CPU';
  return `<div class="unit" data-type="${u.type}">
    <div class="owner ${role==='ally'?'ally':'enemy'}">${owner}</div>
    <div class="nameRow"><div style="font-weight:900">${u.name}</div><div class="badge">${u.type}</div></div>
    <div class="hpRow"><div class="hpBox"><div class="hpFill" id="hp-${role}" style="width:${100*u.hp/u.maxhp}%"></div></div><div class="hpNum" id="hpnum-${role}">HP ${u.hp}/${u.maxhp}</div></div>
    ${gaugeHtml(sp,tag)}
    <div class="skillWrap">
      <div class="skillBox"><div class="skillTitle">✨ 必殺：${u.skill}</div><div class="skillDesc">${u.skillDesc}</div></div>
      <div class="affinityBox">${affText}</div>
    </div>
    ${statBarsHtml(u)}
  </div>`;
}
function attachPop(role,u){const el=document.querySelector(`#card-${role} .skillBox`);el&& (el.onclick=()=>toast(`${u.name}｜HP:${u.maxhp} 攻:${u.atk} 防:${u.def} 回:${u.eva}%｜必殺:${u.skill}… ${u.skillDesc}`));}
const left =()=>state.A.team[state.A.i], right=()=>state.B.team[state.B.i];
function renderSides(){
  $('leftWrap').innerHTML=`<div id="card-ally">${cardHtml(left(),'ally',right())}</div>`;
  $('rightWrap').innerHTML=`<div id="card-enemy">${cardHtml(right(),'enemy',left())}</div>`;
  attachPop('ally',left());attachPop('enemy',right());updateSPBtn();
}

/* ボックス */
function buildBoxes(){
  const mk=u=>`<div class="mini" data-type="${u.type}" data-name="${u.name}">
    <div class="head"><div>${u.name}</div><div class="badge">${u.type}</div></div>
    <div class="miniBar"><span style="width:${100*u.hp/u.maxhp}%"></span></div>
    <div class="meta">HP ${u.hp}/${u.maxhp}</div></div>`;
  $('sixA').innerHTML=state.A.team.map(mk).join('');
  $('sixB').innerHTML=state.B.team.map(mk).join('');
  document.querySelectorAll('#sixA .mini, #sixB .mini').forEach(div=>{
    div.onclick=()=>{const name=div.dataset.name;const u=[...state.A.team,...state.B.team].find(x=>x.name===name);if(!u)return;
      $('infoTitle').textContent=u.name;
      $('infoBody').innerHTML=`<div style="margin:6px 0"><span class="badge">${u.type}</span></div>${statBarsHtml(u)}<div class="skillBox" style="margin-top:8px"><div class="skillTitle">✨ 必殺：${u.skill}</div><div class="skillDesc">${u.skillDesc}</div></div>`;
      $('infoModal').style.display='grid'; $('infoModal').onclick=()=>($('infoModal').style.display='none');
    };
  });
}

/* SPボタン＆満タン通知（通知順は攻撃の後） */
function updateSPBtn(){
  const readyA=state.A.sp>=6, readyB=state.B.sp>=6, btn=$('btnSP');
  if(btn){btn.disabled=!readyA;btn.classList.toggle('on',state.spOn);btn.textContent=state.spOn?'✨ 必殺 ON':'✨ 必殺 OFF';btn.classList.toggle('btnReady',readyA&&!state.spOn);}
  $('gA')?.classList.toggle('readyPulse',readyA); $('gB')?.classList.toggle('readyPulse',readyB);
  if(readyA && !state.spAnnA){toast('あなたの必殺ゲージが満タンだ。'); state.spAnnA=true;}
  if(readyB && !state.spAnnB){toast('相手の必殺ゲージが満タンだ。'); state.spAnnB=true;}
}

/* ターンタイマー（トースト中は止める） */
function startRound(){
  state.remain=15; $('countNum').textContent=state.remain; clearInterval(state.timer);
  state.timer=setInterval(()=>{
    if(toastBusy) return;
    state.remain--; $('countNum').textContent=state.remain;
    if(state.remain<=0){const r=['G','C','P'][Math.floor(Math.random()*3)]; pick(r);}
  },1000);
}

/* じゃんけん */
function judge(a,b){if(a===b)return 0;if((a==='G'&&b==='C')||(a==='C'&&b==='P')||(a==='P'&&b==='G'))return 1;return -1;}
function rand(){return Math.random();}
function baseDamage(att,def){return 100*(1+att.atk/100)/(1+def.def/120)*typeMult(att.type,def.type);}

/* 攻撃（HP減少は「ダメージ」トーストの後） */
async function doAttack(att,def,useSP,role){
  if(att.hp<=0)return;

  // 必殺トースト（Xはコピー元も明示）
  if(useSP){
    let nameLine=`${att.name}の必殺、「${att.skill}」！`;
    let descLine=att.skillDesc;
    if(att.rank==='X'){
      const enemyTeam=(role==='ally'?state.B.team:state.A.team).filter(u=>u.rank!=='X' && u.hp>0);
      if(enemyTeam.length){
        const picked=enemyTeam[Math.floor(Math.random()*enemyTeam.length)];
        const [copiedName,copiedDesc]=SKILLS[picked.name]||["—","—"];
        nameLine=`${att.name}の必殺、「鏡文字」！（${picked.name}の「${copiedName}」をコピー）`;
        descLine=copiedDesc;
      }
    }
    const el=role==='ally'?$('card-ally'):$('card-enemy');
    el?.classList.add('fx-burst');setTimeout(()=>el?.classList.remove('fx-burst'),280);
    toast(nameLine); await delay(500); toast(descLine); await delay(400);
  }

  // 命中判定（通常のみ）
  const miss=(!useSP && rand() < (def.eva/100));
  if(miss){
    const vr=role==='ally'?'enemy':'ally';
    $('card-'+vr)?.classList.add('shake');setTimeout(()=>$('card-'+vr)?.classList.remove('shake'),500);
    const msg=`${att.name}の攻撃は外れた！`;
    toast(msg); await delay(toastDuration(msg));
    return;
  }

  // ダメージ
  let base=baseDamage(att,def); if(useSP) base*=2.0;
  let dmg=0;
  if(useSP && att.name==="そぼろごはん"){[0.75,0.5,0.25].forEach(s=>dmg+=Math.max(1,Math.round(base*s)));} else {dmg=Math.max(1,Math.round(base));}
  const msg=`${att.name}の${useSP?'必殺！':'攻撃！'} ${dmg}ダメージ！`;

  // 受け側シェイク → 「ダメージ」トースト → その後HP減少
  const vr=role==='ally'?'enemy':'ally';
  $('card-'+vr)?.classList.add('shake'); setTimeout(()=>$('card-'+vr)?.classList.remove('shake'),500);
  toast(msg); await delay(toastDuration(msg)); // 表示後にHP反映

  def.hp=Math.max(0,def.hp-dmg); updateHpBars(vr,def);

  if(def.hp<=0){
    const koMsg=`${def.name}は倒れた！`;
    toast(koMsg); await delay(toastDuration(koMsg));
    await handleKO(vr);
  }
}

/* HPバー更新 */
function updateHpBars(role,unit){
  const b=$('hp-'+role),n=$('hpnum-'+role);
  if(b) b.style.width=`${100*unit.hp/unit.maxhp}%`;
  if(n) n.textContent=`HP ${unit.hp}/${unit.maxhp}`;
}

/* KO → 強制交代 or 勝敗
   ※撃破後の交代では「追加攻撃なし」（ダブル被弾を防止）
   ※交代時は必殺ゲージ0 */
async function handleKO(side){
  if(side==='ally'){
    const can=[0,1,2].filter(i=>i!==state.A.i && state.A.team[i].hp>0);
    if(can.length){
      const i=await openSwitchAuto(15,can,false); // 強制（キャンセル不可）
      state.A.i=i; state.A.sp=0; state.spOn=false; updateSPBtn();
      toast(`いけ、${left().name}！`); renderSides(); buildBoxes();
      // ★ここでは相手の追撃をしない（要望対応）
      startRound();
    } else { return showResult(false); }
  }else{
    const can=[0,1,2].filter(i=>i!==state.B.i && state.B.team[i].hp>0);
    if(can.length){
      // AIは相性有利を優先
      let best=can[0],m0=typeMult(state.B.team[best].type,left().type);
      for(const k of can){const m=typeMult(state.B.team[k].type,left().type); if(m>m0){best=k;m0=m;}}
      state.B.i=best; state.B.sp=0; updateSPBtn();
      toast(`相手は ${right().name} をくりだした！`); renderSides(); buildBoxes();
      // 相手側も追撃しない
      startRound();
    } else { return showResult(true); }
  }
}

/* 交代モーダル（手動/強制） */
const modal=$('switchModal'),grid=$('switchGrid'),doBtn=$('swDo'),cancelBtn=$('swCancel'),swTimer=$('swTimer');let selectIdx=null,swInterval=null;
function openSwitch(){ return openSwitchAuto(15,null,true); } // 手動：キャンセル可
function openSwitchAuto(sec=15,canList=null,allowCancel=false){
  return new Promise(resolve=>{
    grid.innerHTML='';selectIdx=null;doBtn.disabled=true;modal.style.display='grid';
    const idxs=(canList??[0,1,2].filter(i=>i!==state.A.i && state.A.team[i].hp>0));
    idxs.forEach(i=>{
      const u=state.A.team[i], mul=typeMult(u.type,right().type);
      const div=document.createElement('div');div.className='setupMini selCard';div.setAttribute('data-type',u.type);
      div.innerHTML=`<div class="head"><div>${u.name}</div><div class="badge">${u.type}</div></div>${barRow('HP',u.hp,u.maxhp)}<div class="meta">相性：${mul===1.5?'x1.5（抜群）':mul===0.67?'x0.67（いまいち）':'x1.0（等倍）'}</div>`;
      div.addEventListener('click',()=>{document.querySelectorAll('.selCard').forEach(x=>x.classList.remove('selected'));div.classList.add('selected');selectIdx=i;doBtn.disabled=false;});
      grid.append(div);
    });
    let remain=sec; swTimer.textContent=`自動交代まで ${remain} 秒`; clearInterval(swInterval);
    swInterval=setInterval(()=>{ if(toastBusy) return; remain--; swTimer.textContent=`自動交代まで ${remain} 秒`; if(remain<=0){clearInterval(swInterval); auto();}},1000);
    const close=i=>{modal.style.display='none';clearInterval(swInterval);resolve(i);};
    const auto=()=>{const r=idxs[Math.floor(Math.random()*idxs.length)];close(r);};
    doBtn.onclick=()=>{if(selectIdx==null)return;close(selectIdx);};
    cancelBtn.onclick=()=>{ if(allowCancel){ close(null); } else { auto(); } }; // 強制時は自動に落ちる
  });
}

/* 勝敗 */
function showResult(win){
  $('resTitle').textContent=win?'YOU WIN!':'YOU LOSE...';
  $('result').style.display='grid';
  setTimeout(()=>{$('result').style.display='none'; document.body.classList.remove('battleMode');$('battle').style.display='none';$('setup').style.display='block';},3000);
}

/* ラウンド進行
   1) 結果トースト
   2) 必要なら攻撃（この時点のSP状態のみ参照）
   3) 攻撃が終わってから双方のゲージ+1 → 満タン通知
*/
async function pick(h){
  if(state.busy) return; state.busy=true; clearInterval(state.timer);
  const cpuH=['G','C','P'][Math.floor(Math.random()*3)], map={G:'グー',C:'チョキ',P:'パー'};
  const res=judge(h,cpuH);
  const head=`あなたは ${map[h]}。相手は ${map[cpuH]}。${res>0?'あなたの勝ち':res<0?'あなたの負け':'あいこ'}。`;
  toast(head); await delay(toastDuration(head));

  // 先に攻撃（SPは「現時点」だけを見る）
  if(res>0){
    await doAttack(left(),right(), state.spOn && state.A.sp>=6,'ally');
    if(state.spOn && state.A.sp>=6){ state.A.sp=0; state.spOn=false; state.spAnnA=false; }
  }else if(res<0){
    await doAttack(right(),left(), state.B.sp>=6,'enemy');
    if(state.B.sp>=6){ state.B.sp=0; state.spAnnB=false; }
  }

  // 攻撃後にゲージ+1 → 満タントースト（updateSPBtn内で通知）
  const wasA=state.A.sp, wasB=state.B.sp;
  state.A.sp=Math.min(6,wasA+1); state.B.sp=Math.min(6,wasB+1);
  if(state.A.sp>=6 && wasA<6) state.spAnnA=false;
  if(state.B.sp>=6 && wasB<6) state.spAnnB=false;

  renderSides(); buildBoxes(); updateSPBtn();
  state.busy=false; startRound();
}

/* 手動交代：交代直後は相手が即行動（従来仕様） */
async function afterSwitchOpponentActs(){
  await delay(200);
  await doAttack(right(), left(), state.B.sp>=6, 'enemy');
  if(state.B.sp>=6){state.B.sp=0;state.spAnnB=false;}
  renderSides(); buildBoxes(); updateSPBtn(); startRound();
}

/* 初期化 */
function ensureBattleMode(){document.body.classList.add('battleMode');$('setup').style.display='none';$('battle').style.display='block';}
function buildSetup(){makeTeam($('teamA'),'A');makeTeam($('teamB'),'B');}
function bindClicks(){
  $('btnRand').onclick=()=>{const a=uniqueRandom(3,WORDS_BASE.length),b=uniqueRandom(3,WORDS_BASE.length);
    a.forEach((v,i)=>$(`A-${i}`).value=v); b.forEach((v,i)=>$(`B-${i}`).value=v);
    enforceUnique('A');enforceUnique('B');renderMini('A');renderMini('B');toast('ランダムでチームを編成した。');};
  $('btnStart').onclick=()=>{state.A.team=collect('A');state.B.team=collect('B');state.A.i=0;state.B.i=0;state.A.sp=0;state.B.sp=0;state.spOn=false;state.spAnnA=false;state.spAnnB=false;ensureBattleMode();renderSides();buildBoxes();(async()=>{const m=`いけ、${left().name}！バトルスタート！`;toast(m);await delay(toastDuration(m));startRound();})();};
  $('btnG').onclick=()=>pick('G'); $('btnC').onclick=()=>pick('C'); $('btnP').onclick=()=>pick('P');
  $('btnSwitch').onclick=async()=>{const i=await openSwitch(); if(i!=null){state.A.i=i; state.A.sp=0; state.spOn=false; updateSPBtn(); toast(`いけ、${left().name}！`); renderSides(); buildBoxes(); await afterSwitchOpponentActs();}};
  $('btnSP').onclick=()=>{if(state.A.sp>=6){state.spOn=!state.spOn;updateSPBtn();}};
}
document.addEventListener('DOMContentLoaded',()=>{buildSetup();bindClicks();toast('READY: v7.16');});
})();
</script>
</body>
</html>

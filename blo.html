<div><br class="Apple-interchange-newline"><!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>苗字バトル - Update</title>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;500;700;900&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Shippori Mincho', 'Times New Roman', serif;
            background-color: #1c1917;
            margin: 0;
            overflow: hidden;
            touch-action: manipulation;
            color: #e5e5e5;
        }
        
        @keyframes sakura {
            0% { transform: translateY(0) rotate(0deg) translateX(0); opacity: 0; }
            20% { opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg) translateX(50px); opacity: 0; }
        }
        .animate-sakura { animation: sakura linear forwards; }

        @keyframes confetti {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        .animate-confetti { animation: confetti 2.5s ease-out forwards; }
        
        .glass-jp { 
            background: rgba(20, 20, 20, 0.85); 
            backdrop-filter: blur(8px); 
            border: 1px solid rgba(255,255,255,0.15); 
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5); 
        }
        
        .animate-fade-in { animation: fadeIn 0.5s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .animate-spin-slow { animation: spin 8s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .animate-bounce-custom { animation: bounce 1s infinite; }
        @keyframes bounce { 
            0%, 100% { transform: translateY(0); } 
            50% { transform: translateY(-10px); } 
        }

        /* Cut-in Animation */
        @keyframes cutInSlide {
            0% { transform: translateX(-100%) skewX(-20deg); opacity: 0; }
            20% { transform: translateX(0) skewX(-20deg); opacity: 1; }
            80% { transform: translateX(0) skewX(-20deg); opacity: 1; }
            100% { transform: translateX(100%) skewX(-20deg); opacity: 0; }
        }
        .animate-cut-in { animation: cutInSlide 2.5s cubic-bezier(0.16, 1, 0.3, 1) forwards; }

        .bg-noise { background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E"); }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Icons ---
        const Icon = ({ path, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                {path}
            </svg>
        );

        const Search = (p) => <Icon {...p} path={<React.Fragment><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></React.Fragment>} />;
        const User = (p) => <Icon {...p} path={<React.Fragment><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></React.Fragment>} />;
        const XCircle = (p) => <Icon {...p} path={<React.Fragment><circle cx="12" cy="12" r="10"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/></React.Fragment>} />;
        const Crown = (p) => <Icon {...p} path={<React.Fragment><path d="m2 4 3 12h14l3-12-6 7-4-7-4 7-6-7zm3 16h14"/></React.Fragment>} />;
        const History = (p) => <Icon {...p} path={<React.Fragment><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/><path d="M12 7v5l4 2"/></React.Fragment>} />;
        const Skull = (p) => <Icon {...p} path={<React.Fragment><circle cx="9" cy="12" r="1"/><circle cx="15" cy="12" r="1"/><path d="M8 20v2h8v-2"/><path d="m12.5 17-.5-1-.5 1h1z"/><path d="M16 20a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 20"/></React.Fragment>} />;
        const Flower = (p) => <Icon {...p} path={<React.Fragment><path d="M12 7.5a4.5 4.5 0 1 1 4.5 4.5M12 7.5A4.5 4.5 0 1 0 7.5 12M12 7.5V9m-4.5 3a4.5 4.5 0 1 1 4.5-4.5M7.5 12A4.5 4.5 0 1 0 12 16.5M7.5 12H9m4.5 3a4.5 4.5 0 1 1-4.5 4.5M12 16.5A4.5 4.5 0 1 0 16.5 12M12 16.5V15"/></React.Fragment>} />;
        const Sparkles = (p) => <Icon {...p} path={<React.Fragment><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 3v4"/><path d="M3 5h4"/><path d="M3 9h4"/></React.Fragment>} />;
        const ExternalLink = (p) => <Icon {...p} path={<React.Fragment><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" x2="21" y1="14" y2="3"/></React.Fragment>} />;
        const Maximize2 = (p) => <Icon {...p} path={<React.Fragment><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/></React.Fragment>} />;
        const Clock = (p) => <Icon {...p} path={<React.Fragment><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></React.Fragment>} />;
        const Target = (p) => <Icon {...p} path={<React.Fragment><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></React.Fragment>} />;
        const Hourglass = (p) => <Icon {...p} path={<React.Fragment><path d="M5 22h14"/><path d="M5 2h14"/><path d="M17 22v-4.172a2 2 0 0 0-.586-1.414L12 12l-4.414 4.414A2 2 0 0 0 7 17.828V22"/><path d="M7 2v4.172a2 2 0 0 0 .586 1.414L12 12l4.414-4.414A2 2 0 0 0 17 6.172V2"/></React.Fragment>} />;


        // --- Components ---

        const CherryBlossoms = ({ intensity = 'normal' }) => {
            const count = intensity === 'high' ? 60 : 20;
            return (
                <div className="fixed inset-0 pointer-events-none z-0 overflow-hidden">
                {[...Array(count)].map((_, i) => (
                    <div
                    key={i}
                    className="absolute animate-sakura"
                    style={{
                        left: `${Math.random() * 100}%`,
                        top: `-10%`,
                        backgroundColor: Math.random() > 0.6 ? '#fecaca' : '#fce7f3',
                        width: `${Math.random() * 10 + 8}px`,
                        height: `${Math.random() * 10 + 8}px`,
                        animationDuration: `${Math.random() * 5 + 5}s`,
                        animationDelay: `${Math.random() * 5}s`,
                        borderRadius: '60% 0 60% 0',
                        opacity: Math.random() * 0.5 + 0.3,
                    }}
                    />
                ))}
                </div>
            );
        };

        const Confetti = () => {
            return (
                <div className="fixed inset-0 pointer-events-none z-50 overflow-hidden">
                {[...Array(100)].map((_, i) => (
                    <div
                    key={i}
                    className="absolute animate-confetti"
                    style={{
                        left: `${Math.random() * 100}%`,
                        top: `-10%`,
                        backgroundColor: ['#FFD700', '#FF4500', '#FFFFFF', '#00BFFF', '#FF69B4'][Math.floor(Math.random() * 5)],
                        width: `${Math.random() * 8 + 4}px`,
                        height: `${Math.random() * 8 + 4}px`,
                        animationDuration: `${Math.random() * 2 + 1.5}s`,
                        animationDelay: `${Math.random() * 2}s`,
                    }}
                    />
                ))}
                </div>
            );
        };

        const PlayerCard = ({ player, isActive, isWinner, gameMode }) => {
            return (
                <div 
                className={`
                    relative overflow-hidden transition-all duration-700 ease-out 
                    ${isActive ? 'scale-105 border-rose-400/60 bg-black/60 shadow-[0_0_25px_rgba(251,113,133,0.2)]' : 'scale-100 border-stone-700/50 bg-black/40 opacity-70'}
                    ${player.isOut ? 'grayscale opacity-30' : ''}
                    border rounded-sm p-4 flex flex-col justify-between h-32 w-full
                    font-serif
                `}
                >
                <div className="absolute inset-0 bg-noise opacity-10 pointer-events-none"></div>

                {isActive && !player.isOut && (
                    <div className="absolute top-0 right-0 p-1">
                    <Flower size={16} className="text-rose-400 animate-spin-slow" />
                    </div>
                )}
                
                <div>
                    <div className="flex items-center gap-2 mb-2 border-b border-white/10 pb-1">
                    {isWinner ? <Crown className="w-4 h-4 text-yellow-500" /> : <User className={`w-4 h-4 ${isActive ? 'text-rose-300' : 'text-stone-500'}`} />}
                    <span className={`font-bold tracking-widest text-sm ${isActive ? 'text-rose-50' : 'text-stone-400'}`}>{player.name}</span>
                    </div>
                </div>

                <div className="flex justify-between items-end">
                    {gameMode === 'SURVIVAL' ? (
                        <>
                            <div className="flex gap-1">
                            {[...Array(3)].map((_, i) => (
                                <div key={i} className={`transform ${i < player.strikes ? 'text-stone-800' : 'text-rose-500'}`}>
                                {i < player.strikes ? <XCircle size={16} /> : <div className="w-3 h-3 rounded-full bg-rose-500 shadow-[0_0_5px_rgba(244,63,94,0.6)]"></div>}
                                </div>
                            ))}
                            </div>
                            <div className="text-right">
                                <div className="text-[10px] text-stone-500 mb-0.5 tracking-tighter">最良</div>
                                <div className={`font-serif font-bold text-lg leading-none ${player.bestScore === 999999 ? 'text-stone-700' : 'text-rose-300'}`}>
                                    {player.bestScore === 999999 ? '---' : `${player.bestScore.toLocaleString()}`}
                                    <span className="text-[10px] ml-1 text-stone-600">人</span>
                                </div>
                            </div>
                        </>
                    ) : (
                        /* 近似値対決用: 勝利数(★)表示 */
                        <div className="w-full">
                            <div className="text-[10px] text-stone-500 mb-1 tracking-tighter">勝利数</div>
                            <div className="flex gap-1">
                                {[...Array(3)].map((_, i) => (
                                    <div key={i}>
                                        {i < player.wins ? (
                                            <Crown size={20} className="text-yellow-500 fill-yellow-500 animate-bounce-custom" style={{ animationDelay: `${i * 0.2}s` }} />
                                        ) : (
                                            <div className="w-5 h-5 rounded-full border border-stone-700 bg-stone-900/50"></div>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
                
                {player.isOut && (
                    <div className="absolute inset-0 flex items-center justify-center bg-black/80 z-10 backdrop-blur-sm">
                    <span className="text-stone-500 font-serif font-black text-2xl tracking-[0.5em] border-y border-stone-500 py-1">脱落</span>
                    </div>
                )}
                </div>
            );
        };

        const CutIn = ({ text, subText }) => (
            <div className="fixed inset-0 z-[100] pointer-events-none flex items-center justify-center overflow-hidden">
                <div className="w-full h-48 bg-rose-900/90 absolute transform -skew-x-12 animate-cut-in flex items-center justify-center border-y-4 border-yellow-500 shadow-2xl">
                    <div className="transform skew-x-12 text-center text-white drop-shadow-md">
                        <div className="text-xl font-bold text-yellow-300 tracking-[0.5em] mb-2">{subText}</div>
                        <div className="text-6xl font-black tracking-widest">{text}</div>
                    </div>
                </div>
            </div>
        );

        const SurnameHunterGame = () => {
            const MAX_ROUNDS_SURVIVAL = 5; 
            const TARGET_LIST = [10, 50, 100, 1000, 3000, 5000, 10000, 20000, 50000];
            const TURN_TIME_LIMIT = 30; // 30秒
            const TRANSITION_TIME = 5; // 5秒

            // State
            const [phase, setPhase] = useState('SETUP'); 
            const [gameMode, setGameMode] = useState('SURVIVAL');
            
            const [players, setPlayers] = useState([
                { id: 1, name: 'Player 1', strikes: 0, wins: 0, isOut: false, bestScore: 999999 },
                { id: 2, name: 'Player 2', strikes: 0, wins: 0, isOut: false, bestScore: 999999 },
            ]);
            const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
            const [currentRound, setCurrentRound] = useState(1);
            const [inputName, setInputName] = useState('');
            const [searchUrl, setSearchUrl] = useState('');
            const [globalHistory, setGlobalHistory] = useState([]);
            const [minRecord, setMinRecord] = useState({ holder: null, count: 999999, name: '' });
            
            // TARGETモード用
            const [targetNumber, setTargetNumber] = useState(0);
            const [roundResults, setRoundResults] = useState([]); 
            const [roundWinner, setRoundWinner] = useState(null); 
            const [drawReason, setDrawReason] = useState(null);

            // 新機能用 State
            const [timeLeft, setTimeLeft] = useState(0);
            const [turnConstraint, setTurnConstraint] = useState(null); // null or 1 or 2 or 3
            const [showCutIn, setShowCutIn] = useState(false);

            const inputRef = useRef(null);
            const searchWindowRef = useRef(null);
            const timerRef = useRef(null);

            // --- Effects ---

            // タイマー管理
            useEffect(() => {
                if (phase === 'PLAYING' || phase === 'TURN_TRANSITION') {
                    if (timeLeft > 0) {
                        timerRef.current = setTimeout(() => {
                            setTimeLeft(timeLeft - 1);
                        }, 1000);
                    } else {
                        handleTimerComplete();
                    }
                }
                return () => clearTimeout(timerRef.current);
            }, [timeLeft, phase]);

            const handleTimerComplete = () => {
                if (phase === 'TURN_TRANSITION') {
                    // 待機画面終了 -> プレイ開始
                    setPhase('PLAYING');
                    setTimeLeft(TURN_TIME_LIMIT);
                    
                    // 第4回戦以降、文字数縛りがある場合はカットイン表示
                    if (turnConstraint) {
                        setShowCutIn(true);
                        setTimeout(() => setShowCutIn(false), 2500);
                    }
                } else if (phase === 'PLAYING') {
                    // プレイ時間切れ -> 強制ドボン
                    if (searchWindowRef.current && !searchWindowRef.current.closed) {
                        searchWindowRef.current.close();
                    }
                    alert("時間切れ！強制ドボンとなります。");
                    handleResultSubmit('STRIKE'); // ドボン扱い
                }
            };

            // --- Logic ---

            const addPlayer = () => {
                if (players.length >= 4) return;
                const name = `Player ${players.length + 1}`;
                setPlayers([...players, { id: players.length + 1, name, strikes: 0, wins: 0, isOut: false, bestScore: 999999 }]);
            };

            const removePlayer = (id) => {
                if (players.length <= 2) return;
                setPlayers(players.filter(p => p.id !== id));
            };

            const startGame = (mode) => {
                setGameMode(mode);
                setGlobalHistory([]);
                setCurrentRound(1);
                setCurrentPlayerIndex(0);
                setTurnConstraint(null);
                setPlayers(players.map(p => ({ ...p, strikes: 0, wins: 0, isOut: false, bestScore: 999999 })));

                if (mode === 'TARGET') {
                    setupNextTargetRound(1);
                } else {
                    // サバイバルモードもトランジションを経由する
                    startTurnSequence(0, 1);
                }
            };

            const setupNextTargetRound = (roundNum) => {
                const newTarget = TARGET_LIST[Math.floor(Math.random() * TARGET_LIST.length)];
                setTargetNumber(newTarget);
                setRoundResults([]);
                setRoundWinner(null);
                setDrawReason(null);
                setCurrentRound(roundNum);
                
                const startIndex = (roundNum - 1) % players.length;
                setCurrentPlayerIndex(startIndex); // 表示用(REVEAL画面でも誰からか分かるように)
                
                setPhase('TARGET_REVEAL');
            };

            // 手番開始シーケンス（トランジション開始）
            const startTurnSequence = (nextIndex, roundNum = currentRound) => {
                setCurrentPlayerIndex(nextIndex);
                setCurrentRound(roundNum);
                setInputName('');

                // 縛り決定ロジック (TARGETモード かつ 4回戦以降)
                let constraint = null;
                if (gameMode === 'TARGET' && roundNum >= 4) {
                    const p = players[nextIndex];
                    const rand = Math.random();
                    // 勝利数が多いほど文字数が多い縛り(3文字)が出やすい傾向
                    // 0勝: 1(33%), 2(33%), 3(33%)
                    // 1勝: 1(20%), 2(40%), 3(40%)
                    // 2勝以上: 1(10%), 2(20%), 3(70%)
                    let w1 = 0.33;
                    let w2 = 0.66;
                    
                    if (p.wins === 1) { w1 = 0.2; w2 = 0.6; }
                    if (p.wins >= 2) { w1 = 0.1; w2 = 0.3; }

                    if (rand < w1) constraint = 1;
                    else if (rand < w2) constraint = 2;
                    else constraint = 3;
                }
                setTurnConstraint(constraint);

                // トランジション開始
                setPhase('TURN_TRANSITION');
                setTimeLeft(TRANSITION_TIME);
            };


            const openSearchPopup = (url) => {
                const width = 500;
                const height = 700;
                const left = window.screen.width ? (window.screen.width - width) / 2 : 0;
                const top = window.screen.height ? (window.screen.height - height) / 2 : 0;
                const features = `width=${width},height=${height},top=${top},left=${left},scrollbars=yes,resizable=yes`;

                if (!searchWindowRef.current || searchWindowRef.current.closed) {
                    searchWindowRef.current = window.open(url, 'SurnameSearch', features);
                } else {
                    try {
                        searchWindowRef.current.location.href = url;
                        searchWindowRef.current.focus();
                    } catch (e) {
                        searchWindowRef.current = window.open(url, 'SurnameSearch', features);
                    }
                }
                setTimeout(() => {
                    if (searchWindowRef.current && !searchWindowRef.current.closed) {
                        searchWindowRef.current.close();
                        searchWindowRef.current = null;
                    }
                }, 3000);
            };

            const handleSearch = (e) => {
                e.preventDefault();
                const name = inputName.trim();
                if (!name) return;

                // 縛りチェック
                if (turnConstraint && name.length !== turnConstraint) {
                    alert(`【縛り違反】\n現在は「${turnConstraint}文字」の苗字しか検索できません！`);
                    return;
                }
                
                if (globalHistory.some(h => h.name === name)) {
                    alert("その苗字は既出でございます。");
                    return;
                }

                const url = `https://myoji-yurai.net/searchResult.htm?myojiKanji=${encodeURIComponent(name)}`;
                setSearchUrl(url);
                openSearchPopup(url);
                setPhase('SEARCHING');
            };

            const handleResultSubmit = (type, value = 0) => {
                const currentPlayer = players[currentPlayerIndex];
                let newPlayers = [...players];
                let newHistoryItem = { 
                    player: currentPlayer.name, 
                    name: inputName || (type === 'STRIKE' ? 'TIMEOUT' : ''), 
                    count: value, 
                    result: type,
                };
                
                setInputName('');

                // 1. SURVIVAL MODE LOGIC
                if (gameMode === 'SURVIVAL') {
                    if (type === 'WIN' || (type === 'COUNT' && value === 10)) {
                        newPlayers[currentPlayerIndex].bestScore = 10;
                        setPhase('WIN');
                        setGlobalHistory([newHistoryItem, ...globalHistory]);
                        setPlayers(newPlayers);
                        return;
                    } else if (type === 'STRIKE') {
                        newPlayers[currentPlayerIndex].strikes += 1;
                        newHistoryItem.count = '不明';
                        if (newPlayers[currentPlayerIndex].strikes >= 3) newPlayers[currentPlayerIndex].isOut = true;
                    } else if (type === 'COUNT') {
                        if (value < newPlayers[currentPlayerIndex].bestScore) newPlayers[currentPlayerIndex].bestScore = value;
                        if (value < minRecord.count) setMinRecord({ holder: currentPlayer.name, count: value, name: inputName });
                    }

                    setPlayers(newPlayers);
                    setGlobalHistory([newHistoryItem, ...globalHistory]);

                    const alivePlayers = newPlayers.filter(p => !p.isOut);
                    if (alivePlayers.length === 0) {
                        setPhase('GAMEOVER');
                    } else if (alivePlayers.length === 1 && newPlayers.length > 1) {
                        setPhase('SURVIVOR_WIN');
                    } else {
                        let nextIndex = (currentPlayerIndex + 1) % players.length;
                        while (newPlayers[nextIndex].isOut) nextIndex = (nextIndex + 1) % players.length;

                        // ラウンド更新チェック
                        let nextRound = currentRound;
                        if (nextIndex < currentPlayerIndex) {
                            nextRound = currentRound + 1;
                            if (nextRound > MAX_ROUNDS_SURVIVAL) {
                                setPhase('TIME_UP_WIN');
                                return;
                            }
                        }
                        // 次のプレイヤーへの遷移
                        startTurnSequence(nextIndex, nextRound);
                    }
                } 
                // 2. TARGET MODE LOGIC
                else {
                    const isDobon = type === 'STRIKE' || value === 0;
                    const diff = isDobon ? null : Math.abs(value - targetNumber);
                    
                    const resultData = {
                        playerId: currentPlayer.id,
                        playerName: currentPlayer.name,
                        name: inputName || 'TIMEOUT',
                        count: isDobon ? (type === 'STRIKE' ? '該当なし/時間切' : '0人') : value,
                        diff: diff,
                        isDobon: isDobon
                    };
                    
                    const updatedRoundResults = [...roundResults, resultData];
                    setRoundResults(updatedRoundResults);
                    setGlobalHistory([newHistoryItem, ...globalHistory]); 

                    if (updatedRoundResults.length === players.length) {
                        const validResults = updatedRoundResults.filter(r => !r.isDobon);
                        let winner = null;

                        if (validResults.length === 0) {
                            setDrawReason('ALL_DOBON');
                            setRoundWinner(null);
                        } else {
                            const minDiff = Math.min(...validResults.map(r => r.diff));
                            const winners = validResults.filter(r => r.diff === minDiff);
                            
                            if (winners.length > 1) {
                                setDrawReason('TIE');
                                setRoundWinner(null);
                            } else {
                                winner = winners[0];
                                const winnerIndex = newPlayers.findIndex(p => p.id === winner.playerId);
                                newPlayers[winnerIndex].wins += 1;
                                setPlayers(newPlayers);
                                setRoundWinner(winner);
                                setDrawReason(null);
                            }
                        }
                        setPhase('ROUND_RESULT');
                    } else {
                        // 次の人へ
                        const nextIndex = (currentPlayerIndex + 1) % players.length;
                        startTurnSequence(nextIndex);
                    }
                }
            };

            const nextTargetRoundAction = () => {
                const grandWinner = players.find(p => p.wins >= 3);
                if (grandWinner) {
                    setPhase('FINAL_WIN');
                    return;
                }
                setupNextTargetRound(currentRound + 1);
            };

            // --- Render ---
            const Background = () => (
                <div className="fixed inset-0 bg-[#1c1917] z-[-1]">
                <CherryBlossoms intensity={['WIN', 'SURVIVOR_WIN', 'TIME_UP_WIN', 'FINAL_WIN'].includes(phase) ? 'high' : 'normal'} />
                {['WIN', 'SURVIVOR_WIN', 'TIME_UP_WIN', 'FINAL_WIN', 'ROUND_RESULT'].includes(phase) && roundWinner !== null && (
                    <Confetti />
                )}
                </div>
            );

            // 1. SETUP
            if (phase === 'SETUP') {
                return (
                <div className="min-h-screen text-stone-200 font-serif flex items-center justify-center p-4 relative overflow-hidden">
                    <Background />
                    <div className="w-full max-w-md space-y-10 z-10">
                    <div className="text-center space-y-4">
                        <div className="inline-block p-4 border-2 border-rose-900/50 rounded-full mb-2 bg-black/40">
                            <Flower className="w-10 h-10 text-rose-400" />
                        </div>
                        <h1 className="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-b from-rose-100 via-rose-300 to-rose-600 tracking-widest drop-shadow-lg leading-tight">
                        苗字<br/>バトル
                        </h1>
                        <p className="text-stone-500 text-sm tracking-[0.3em] uppercase">- SURNAME BATTLE -</p>
                    </div>
                    
                    <div className="space-y-4 bg-black/40 p-6 rounded-lg border border-white/5 backdrop-blur-sm">
                        {players.map((player) => (
                        <div key={player.id} className="flex gap-2 items-center">
                            <span className="text-xs text-stone-600 w-4 text-center">{player.id}</span>
                            <input
                            value={player.name}
                            onChange={(e) => setPlayers(players.map(p => p.id === player.id ? {...p, name: e.target.value} : p))}
                            className="flex-1 bg-transparent border-b border-stone-700 py-2 px-2 text-rose-50 placeholder-stone-700 focus:border-rose-500 outline-none transition-colors text-lg"
                            placeholder="名前を入力"
                            />
                            {players.length > 2 && <button onClick={() => removePlayer(player.id)} className="text-stone-600 hover:text-rose-500 transition-colors"><XCircle size={18} /></button>}
                        </div>
                        ))}
                        {players.length < 4 && (
                        <button onClick={addPlayer} className="w-full py-3 border border-dashed border-stone-800 text-stone-600 text-sm hover:border-rose-900 hover:text-rose-400 transition-all">
                            + 参加者を増やす
                        </button>
                        )}
                    </div>
                    
                    <button onClick={() => setPhase('MODE_SELECT')} className="w-full group relative overflow-hidden bg-rose-900/80 hover:bg-rose-800 text-rose-100 font-bold py-5 rounded-sm border border-rose-700/50 transition-all">
                        <span className="relative z-10 flex items-center justify-center gap-3 text-xl tracking-[0.2em]">
                        次へ進む
                        </span>
                    </button>
                    </div>
                </div>
                );
            }

            // 2. MODE SELECT
            if (phase === 'MODE_SELECT') {
                return (
                    <div className="min-h-screen text-stone-200 font-serif flex items-center justify-center p-4 relative overflow-hidden">
                        <Background />
                        <div className="w-full max-w-md space-y-6 z-10 animate-fade-in">
                            <h2 className="text-center text-xl font-bold tracking-widest mb-8">遊戯選択</h2>
                            
                            <button onClick={() => startGame('TARGET')} className="w-full group relative overflow-hidden bg-black/40 hover:bg-yellow-900/40 border border-stone-600 hover:border-yellow-500 p-6 text-left transition-all">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="text-xl font-bold text-yellow-100 group-hover:text-white">人数ピタリを目指せ！</span>
                                    <Target className="text-stone-600 group-hover:text-yellow-500 transition-colors" />
                                </div>
                                <p className="text-xs text-stone-400 leading-relaxed">
                                    指定人数に近い苗字を出す頭脳戦。30秒制限。<br/>
                                    4回戦以降、文字数縛りあり。<br/>
                                    3本先取で優勝。
                                </p>
                            </button>

                            <button onClick={() => startGame('SURVIVAL')} className="w-full group relative overflow-hidden bg-black/40 hover:bg-rose-900/40 border border-stone-600 hover:border-rose-500 p-6 text-left transition-all">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="text-xl font-bold text-rose-100 group-hover:text-white">極レア苗字を探せ！</span>
                                    <Skull className="text-stone-600 group-hover:text-rose-500 transition-colors" />
                                </div>
                                <p className="text-xs text-stone-400 leading-relaxed">
                                    「およそ10人」の激レア苗字を探し出すサバイバル。<br/>
                                    実在しない苗字は即失策。5巡以内の発見を目指せ。
                                </p>
                            </button>
                        </div>
                    </div>
                );
            }

            // 3. TARGET REVEAL
            if (phase === 'TARGET_REVEAL') {
                const starter = players[currentPlayerIndex];
                return (
                    <div className="min-h-screen text-stone-200 font-serif flex items-center justify-center p-4 relative overflow-hidden" 
                         onClick={() => startTurnSequence(currentPlayerIndex, currentRound)}>
                        <Background />
                        <div className="text-center z-10 animate-fade-in cursor-pointer">
                            <div className="text-stone-500 text-sm tracking-widest mb-4">第{currentRound}回戦 お題</div>
                            <div className="text-6xl font-black text-white drop-shadow-[0_0_30px_rgba(234,179,8,0.5)] mb-2">
                                {targetNumber.toLocaleString()}
                            </div>
                            <div className="text-xl text-yellow-500 tracking-widest font-bold">人</div>
                            <div className="mt-8 text-sm text-stone-300">
                                先攻: <span className="font-bold text-white">{starter.name}</span>
                            </div>
                            <p className="mt-8 text-xs text-stone-400 animate-pulse">画面をタップして開始</p>
                        </div>
                    </div>
                );
            }

            // X. TURN TRANSITION (New Phase)
            if (phase === 'TURN_TRANSITION') {
                const nextPlayer = players[currentPlayerIndex];
                return (
                    <div className="min-h-screen text-stone-200 font-serif flex items-center justify-center p-4 relative overflow-hidden">
                        <Background />
                        <div className="text-center z-10 w-full max-w-md animate-fade-in">
                            <h3 className="text-stone-500 tracking-[0.5em] text-xs mb-6">NEXT PLAYER</h3>
                            
                            <div className="text-4xl font-black text-white mb-2">{nextPlayer.name}</div>
                            <p className="text-sm text-stone-400 mb-12">端末を相手に渡してください</p>

                            <div className="relative w-32 h-32 mx-auto flex items-center justify-center">
                                <svg className="absolute inset-0 w-full h-full rotate-[-90deg]" viewBox="0 0 100 100">
                                    <circle cx="50" cy="50" r="45" fill="none" stroke="#333" strokeWidth="5" />
                                    <circle 
                                        cx="50" cy="50" r="45" fill="none" stroke="#e11d48" strokeWidth="5" 
                                        strokeDasharray="283" 
                                        strokeDashoffset={283 - (283 * timeLeft / TRANSITION_TIME)}
                                        className="transition-all duration-1000 ease-linear"
                                    />
                                </svg>
                                <span className="text-5xl font-black text-rose-500">{timeLeft}</span>
                            </div>
                            <p className="mt-8 text-xs text-stone-500 animate-pulse">まもなく開始します...</p>
                        </div>
                    </div>
                );
            }

            // 4. ROUND RESULT (TARGET)
            if (phase === 'ROUND_RESULT') {
                return (
                    <div className="min-h-screen text-stone-200 font-serif flex items-center justify-center p-4 relative overflow-hidden">
                        <Background />
                        <div className="w-full max-w-md z-10 animate-fade-in">
                            <div className="text-center mb-8">
                                <div className="text-xs text-stone-500 tracking-widest mb-2">お題: {targetNumber.toLocaleString()}人</div>
                                {roundWinner ? (
                                    <div className="animate-bounce-custom">
                                        <div className="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-b from-yellow-200 to-yellow-600 mb-2 drop-shadow-lg">勝者: {roundWinner.playerName}</div>
                                        <div className="text-lg text-white font-bold bg-white/10 inline-block px-4 py-1 rounded-full border border-white/20 backdrop-blur-sm">
                                            "{roundWinner.name}" ({typeof roundWinner.count === 'number' ? roundWinner.count.toLocaleString() : roundWinner.count}人)
                                            <span className="text-sm font-normal text-stone-300 ml-2">誤差: {roundWinner.diff.toLocaleString()}</span>
                                        </div>
                                    </div>
                                ) : (
                                    <>
                                        <div className="text-3xl font-bold text-stone-400 mb-1">引き分け - 再戦</div>
                                        <div className="text-sm text-red-400">
                                            {drawReason === 'ALL_DOBON' ? '全員ドボンにより無効' : '誤差が同じため無効'}
                                        </div>
                                    </>
                                )}
                            </div>

                            <div className="space-y-2 mb-8 bg-black/40 p-4 rounded border border-stone-800">
                                {roundResults.map((res, idx) => (
                                    <div key={idx} className={`flex justify-between items-center p-2 border-b ${roundWinner && res.playerId === roundWinner.playerId ? 'border-yellow-500/50 text-yellow-100 bg-yellow-500/10' : 'border-stone-800 text-stone-400'} ${res.isDobon ? 'opacity-50' : ''}`}>
                                        <div className="flex items-center gap-2">
                                            <span className="text-xs w-16 truncate">{res.playerName}</span>
                                            <span className="font-bold">{res.name}</span>
                                        </div>
                                        <div className="text-right text-xs">
                                            <div>{typeof res.count === 'number' ? res.count.toLocaleString() : res.count}</div>
                                            {res.isDobon ? (
                                                <div className="text-[10px] text-red-500 font-bold">ドボン</div>
                                            ) : (
                                                <div className="text-[10px] opacity-70">差: {res.diff.toLocaleString()}</div>
                                            )}
                                        </div>
                                    </div>
                                ))}
                            </div>

                            <button onClick={nextTargetRoundAction} className="w-full bg-stone-800 hover:bg-stone-700 py-4 border border-stone-600 transition-all text-stone-200">
                                {roundWinner ? '次の戦いへ' : '新しいお題でやり直し'}
                            </button>
                        </div>
                    </div>
                );
            }

            // 5. MAIN PLAY SCREEN
            const currentPlayer = players[currentPlayerIndex];

            // 最終結果画面かどうか
            if (['WIN', 'SURVIVOR_WIN', 'GAMEOVER', 'TIME_UP_WIN', 'FINAL_WIN'].includes(phase)) {
                let winnerName = "なし";
                let winReason = "";
                
                if (phase === 'GAMEOVER') {
                    winReason = "全員脱落";
                } else if (gameMode === 'SURVIVAL') {
                    if (phase === 'SURVIVOR_WIN') {
                        const w = players.find(p => !p.isOut);
                        winnerName = w ? w.name : "不明";
                        winReason = "生き残り";
                    } else if (phase === 'TIME_UP_WIN') {
                        winnerName = minRecord.holder;
                        winReason = `最小記録 (${minRecord.count}人: ${minRecord.name})`;
                    } else { // WIN (10人ジャスト)
                        const w = players[currentPlayerIndex];
                        winnerName = w.name;
                        winReason = "奇跡の10人達成";
                    }
                } else { // TARGET FINAL WIN
                    const w = players.find(p => p.wins >= 3);
                    winnerName = w ? w.name : "不明";
                    winReason = "3本先取達成";
                }

                return (
                    <div className="min-h-screen text-stone-200 font-serif flex items-center justify-center p-4 relative overflow-hidden">
                        <Background />
                        <div className="text-center animate-fade-in py-8 z-10 w-full max-w-lg">
                            <div className="mb-8 inline-block relative animate-bounce-custom">
                                {phase === 'GAMEOVER' ? (
                                <div className="text-stone-600 animate-pulse"><Skull size={80} strokeWidth={1} /></div>
                                ) : (
                                <>
                                    <div className="absolute -inset-10 bg-yellow-500/30 blur-2xl rounded-full animate-pulse"></div>
                                    <Crown size={80} className="text-yellow-500 relative z-10 drop-shadow-[0_0_15px_rgba(234,179,8,0.8)]" strokeWidth={1.5} />
                                </>
                                )}
                            </div>
                            
                            <h2 className="text-6xl font-black mb-6 tracking-[0.2em] text-transparent bg-clip-text bg-gradient-to-b from-white to-stone-400 drop-shadow-lg">
                                {phase === 'GAMEOVER' ? '終焉' : '決着'}
                            </h2>
                            
                            <div className="bg-black/60 backdrop-blur-md p-8 rounded-lg border border-white/10 mx-4">
                                <p className="text-xs text-stone-400 mb-2 tracking-widest">VICTOR</p>
                                <p className="text-4xl font-black text-rose-100 mb-4 tracking-widest drop-shadow-md">
                                    {phase === 'GAMEOVER' ? '勝者なし' : winnerName}
                                </p>
                                <div className="h-px w-full bg-gradient-to-r from-transparent via-white/20 to-transparent mb-4"></div>
                                <p className="text-sm text-yellow-500 font-bold">{winReason}</p>
                            </div>
                            
                            <button onClick={() => setPhase('SETUP')} className="mt-12 bg-rose-600 hover:bg-rose-500 text-white font-bold px-12 py-4 rounded-full hover:shadow-[0_0_40px_rgba(225,29,72,0.6)] transition-all tracking-widest text-sm">
                                タイトルへ戻る
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen text-stone-200 font-serif relative overflow-hidden flex flex-col">
                <Background />
                {showCutIn && turnConstraint && (
                    <CutIn text={`${turnConstraint}文字`} subText="縛り発生" />
                )}

                {/* Header */}
                <div className="p-4 flex justify-between items-center border-b border-white/10 bg-black/20 backdrop-blur-sm z-20">
                    <div>
                        <h1 className="text-lg font-bold tracking-widest text-rose-100/80">
                            {gameMode === 'SURVIVAL' ? '極レア苗字を探せ！' : '人数ピタリを目指せ！'}
                        </h1>
                        {/* サバイバルモードのラウンド表示 */}
                        {gameMode === 'SURVIVAL' && ['PLAYING', 'SEARCHING'].includes(phase) && (
                            <div className="text-[10px] text-stone-500 flex items-center gap-1 mt-1">
                                <Clock size={10} /> 第{currentRound}の巡 ({currentRound}/{MAX_ROUNDS_SURVIVAL})
                            </div>
                        )}
                        {/* ターゲットモードのお題表示 */}
                        {gameMode === 'TARGET' && (
                            <div className="text-xs text-yellow-500 font-bold mt-1">お題: {targetNumber.toLocaleString()}人</div>
                        )}
                    </div>
                    {/* サバイバルモードの最小記録 */}
                    {gameMode === 'SURVIVAL' ? (
                        <div className="flex items-center gap-3 border border-rose-900/30 px-4 py-1.5 rounded bg-black/40">
                        <span className="text-xs text-stone-400">最小</span>
                        <div className="flex flex-col items-end leading-none">
                            <div className="flex items-baseline gap-1">
                                <span className="text-xl font-bold text-rose-400">{minRecord.count === 999999 ? '--' : minRecord.count.toLocaleString()}</span>
                                <span className="text-xs text-rose-400/70">人</span>
                            </div>
                            {minRecord.name && <span className="text-[10px] text-stone-500">{minRecord.name}</span>}
                        </div>
                        </div>
                    ) : (
                        // ターゲットモードはタイマー表示
                        <div className={`flex items-center gap-2 px-3 py-1.5 rounded border ${timeLeft <= 10 ? 'border-red-500 bg-red-900/20' : 'border-stone-600 bg-black/40'}`}>
                             <Hourglass size={14} className={timeLeft <= 10 ? 'text-red-500 animate-pulse' : 'text-stone-400'} />
                             <span className={`text-xl font-bold font-mono ${timeLeft <= 10 ? 'text-red-500' : 'text-stone-200'}`}>
                                 {timeLeft}
                             </span>
                        </div>
                    )}
                </div>

                {/* Main Content */}
                <div className="flex-1 flex flex-col p-4 max-w-lg mx-auto w-full z-10">
                    
                    {/* Players */}
                    <div className="grid grid-cols-2 gap-3 mb-6">
                    {players.map((p, idx) => (
                        <PlayerCard 
                            key={p.id} 
                            player={p} 
                            isActive={!p.isOut && idx === currentPlayerIndex} 
                            isWinner={false} // 個別カードでは簡易表示
                            gameMode={gameMode}
                        />
                    ))}
                    </div>

                    {/* Game Action Panel */}
                    <div className={`glass-jp flex-1 rounded-sm p-4 relative flex flex-col justify-center min-h-[450px] transition-all duration-500`}>
                    
                    {phase === 'PLAYING' && (
                        <form onSubmit={handleSearch} className="flex flex-col gap-8 animate-fade-in text-center p-4">
                        <div>
                            <div className="inline-block px-4 py-1 border-x border-rose-500/50 text-rose-300 text-xs tracking-[0.3em] mb-4">手番</div>
                            <div className="text-4xl font-bold text-white drop-shadow-md">{currentPlayer.name}</div>
                            {turnConstraint && (
                                <div className="mt-2 inline-block bg-rose-900/80 text-white text-sm font-bold px-3 py-1 rounded border border-rose-500 animate-pulse">
                                    ⚠ 縛り: {turnConstraint}文字のみ
                                </div>
                            )}
                        </div>
                        <div className="relative">
                            <input
                            ref={inputRef}
                            type="text"
                            value={inputName}
                            onChange={(e) => setInputName(e.target.value)}
                            placeholder={turnConstraint ? `${turnConstraint}文字の苗字` : "苗字を入力"}
                            className="w-full bg-transparent border-b-2 border-stone-600 py-4 text-3xl text-center text-rose-50 placeholder-stone-700 focus:border-rose-500 focus:outline-none transition-all tracking-widest"
                            autoFocus
                            />
                        </div>
                        <button type="submit" disabled={!inputName.trim()} className="w-full bg-stone-800 hover:bg-rose-900/60 text-stone-300 hover:text-rose-100 border border-stone-600 hover:border-rose-500/50 py-4 transition-all flex items-center justify-center gap-2 tracking-widest disabled:opacity-30 disabled:cursor-not-allowed group">
                            <Search size={18} className="group-hover:scale-110 transition-transform" />
                            検索・判定へ
                        </button>
                        </form>
                    )}

                    {phase === 'SEARCHING' && (
                        <div className="flex flex-col h-full animate-fade-in gap-6 justify-center">
                        <div className="text-center">
                            <div className="text-[10px] text-stone-500 tracking-widest mb-2">SEARCHING...</div>
                            <div className="text-5xl font-black text-white tracking-widest drop-shadow-lg mb-4">"{inputName}"</div>
                            <p className="text-xs text-rose-200">別窓（ポップアップ）にて人数を確認せよ</p>
                            <p className="text-[10px] text-stone-500 mt-1">※3秒後に自動で閉じます</p>
                        </div>

                        <div className="flex justify-center">
                            <button 
                            onClick={() => openSearchPopup(searchUrl)}
                            className="flex items-center gap-2 px-6 py-3 bg-stone-800 hover:bg-stone-700 border border-rose-500/30 rounded-full text-rose-400 hover:text-rose-300 transition-all shadow-lg"
                            >
                                <Maximize2 size={16} />
                                <span>ウィンドウを再度開く</span>
                            </button>
                        </div>

                        <div className="space-y-4 pt-4 border-t border-white/5 mt-4">
                            <p className="text-center text-[10px] text-stone-500">―― 結果を入力してください ――</p>
                            
                            {gameMode === 'SURVIVAL' && (
                                <button onClick={() => handleResultSubmit('WIN', 10)} className="w-full bg-gradient-to-r from-amber-700 to-yellow-600 hover:from-amber-600 hover:to-yellow-500 text-white font-bold py-4 rounded-sm flex items-center justify-center gap-3 shadow-[0_4px_20px_rgba(234,179,8,0.2)] border border-yellow-500/30 group transition-all">
                                <Sparkles size={20} className="text-yellow-200 group-hover:spin-slow" /> 
                                <span className="text-lg tracking-widest">奇跡の「およそ10人」</span>
                                <Sparkles size={20} className="text-yellow-200" /> 
                                </button>
                            )}
                            
                            <div className={`grid ${gameMode === 'SURVIVAL' ? 'grid-cols-2' : 'grid-cols-1'} gap-3`}>
                            <button onClick={() => {
                                const countStr = prompt('人数を半角数字で入力してください');
                                if (countStr) {
                                    // 全角数字を半角に変換、カンマ除去
                                    const cleanCount = countStr.replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).replace(/,/g, '');
                                    if (!isNaN(cleanCount) && cleanCount !== '') {
                                        handleResultSubmit('COUNT', parseInt(cleanCount));
                                    }
                                }
                            }} className="bg-stone-800 hover:bg-stone-700 text-stone-300 font-bold py-3 rounded-sm border border-stone-700 transition-all">
                                {gameMode === 'SURVIVAL' ? 'その他の人数' : '人数を入力して決定'}
                            </button>
                            <button onClick={() => handleResultSubmit('STRIKE')} className={`bg-rose-950/50 hover:bg-rose-900/80 text-rose-300 font-bold py-3 rounded-sm border border-rose-900/50 transition-all ${gameMode === 'TARGET' ? 'mt-2 py-2 text-xs opacity-60' : ''}`}>
                                該当なし (失策) / 0人 (ドボン)
                            </button>
                            </div>
                        </div>
                        </div>
                    )}
                    </div>
                </div>

                {/* History Log */}
                <div className="bg-black/40 border-t border-white/5 p-4 max-h-40 overflow-y-auto backdrop-blur-md z-20">
                    <div className="flex items-center gap-2 text-xs font-bold text-stone-500 mb-2 tracking-widest">
                    <History size={12} /> 戦歴
                    </div>
                    <div className="space-y-1">
                    {globalHistory.map((h, i) => (
                        <div key={i} className="flex justify-between text-xs py-2 border-b border-white/5 last:border-0 font-serif">
                        <span className="text-stone-500 w-16 truncate">{h.player}</span>
                        <span className="text-stone-200 font-bold text-sm">{h.name}</span>
                        <span className={`${h.result === 'STRIKE' ? 'text-rose-500' : h.result === 'WIN' ? 'text-yellow-500' : 'text-blue-300'}`}>
                            {h.result === 'STRIKE' ? '失策' : typeof h.count === 'number' ? `${h.count.toLocaleString()}人` : h.count}
                        </span>
                        </div>
                    ))}
                    {globalHistory.length === 0 && <div className="text-stone-700 text-xs text-center py-2">記録なし</div>}
                    </div>
                </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<SurnameHunterGame />);
    </script>
</body>
</html>
</div>

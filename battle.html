<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KOTOBA-BATTLE | 対戦 v7.4.4</title>
<style>
:root{
  --bg:#0b1227; --panel:#0f1633; --muted:#99a7d6; --text:#eaf2ff; --border:#1c2447;
  --ally:#69d3ff; --ally2:#2fb1ff; --enemy:#ff9aa5; --enemy2:#ff6b7a;
  --hp:#6bff8b; --hpBack:#12321f; --gauge:#ffde66; --gaugeBack:#342b0b;
  --toast:#112042; --toastText:#eaf2ff;
  --ok:#61f5a2; --warn:#ffd166; --bad:#ff6b6b;

  /* タイプ背景色 */
  --geo:#112445; --animal:#09273e; --food:#0e2f1d; --concept:#121f44;
  --science:#0b2744; --history:#161e40; --human:#141d3f;
}
*{box-sizing:border-box}
html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,"Noto Sans JP",sans-serif}
h1{margin:0 0 8px 0;font-size:28px}
small.head{display:block;color:var(--muted);margin-bottom:12px}
.wrap{max-width:1120px;margin:18px auto;padding:0 12px}

/* パネル */
.card{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:16px}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
@media(max-width:900px){.grid2{grid-template-columns:1fr}}

.sectionTitle{font-size:20px;margin-bottom:10px}

/* 選択セクション */
.teamBox{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.teamBox h3{margin:0 0 8px 0}
.selRow{display:flex;align-items:center;gap:8px;margin:6px 0}
.selRow select{flex:1;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:#0b1330;color:var(--text)}
.btn{padding:12px 18px;border-radius:12px;border:none;cursor:pointer;font-weight:700}
.btnPrimary{background:#44aaff}
.btnGhost{background:#14224a;border:1px dashed #2c3a70}
.btn:disabled{opacity:.5;cursor:not-allowed}

/* 選択中のステータス（下に2×3グリッドで並ぶ） */
.six{margin-top:14px}
.sixGrid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px}
@media(min-width:1020px){.sixGrid{grid-template-columns:repeat(3,1fr)}}
.sixCol h4{margin:4px 0 8px}
.mini{background:#0b1330;border:1px solid var(--border);border-radius:14px;padding:10px}

/* バトル */
#battle{display:none;margin-top:14px}
.topRow{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.unit{position:relative;border-radius:14px;border:1px solid var(--border);padding:12px;min-height:170px}
.unit.ally{outline:2px solid var(--ally)}
.unit.enemy{outline:2px solid var(--enemy)}
.unit header{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px}
.badge{padding:3px 8px;border-radius:999px;font-size:12px;border:1px solid var(--border);background:rgba(255,255,255,.04)}
.gauge{display:flex;gap:6px;margin:6px 0}
.dot{width:14px;height:14px;border-radius:4px;background:var(--gaugeBack);border:1px solid #5a4a14}
.dot.on{background:var(--gauge)}
.readyPulse{animation:blink .8s infinite}
@keyframes blink{0%,100%{filter:brightness(1)}50%{filter:brightness(1.7)}}

.hpRow{display:flex;align-items:center;gap:10px}
.hpBar{flex:1;height:11px;background:var(--hpBack);border-radius:8px;overflow:hidden}
.hpFill{height:100%;background:var(--hp);width:100%;transition:width .45s ease}
.hpNum{font-size:13px;width:96px;text-align:right}

.box{background:#0b1330;border:1px solid var(--border);border-radius:12px;padding:10px;margin-top:8px}
.box h5{margin:0 0 6px 0;font-size:14px}
.skillName{font-weight:800}
.typeRow{display:flex;gap:12px;align-items:center;margin-top:6px}
.typePill{padding:3px 8px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid var(--border);font-size:12px}

.stats{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
.stat{display:flex;align-items:center;gap:8px}
.sbar{flex:1;height:8px;background:#09102a;border-radius:8px;overflow:hidden}
.sfill{height:100%;background:#5577ff;width:0}

/* タイプ背景（カード全体の色味） */
.unit[data-type="ジオ"]{background:var(--geo)}
.unit[data-type="アニマル"]{background:var(--animal)}
.unit[data-type="フード"]{background:var(--food)}
.unit[data-type="コンセプト"]{background:var(--concept)}
.unit[data-type="サイエンス"]{background:var(--science)}
.unit[data-type="ヒストリー"]{background:var(--history)}
.unit[data-type="ヒューマン"]{background:var(--human)}
/* 輪郭強化 */
.unit[data-type="ジオ"]{box-shadow:0 0 0 2px #6aa1ff inset}
.unit[data-type="アニマル"]{box-shadow:0 0 0 2px #5fc2ff inset}
.unit[data-type="フード"]{box-shadow:0 0 0 2px #8bd38b inset}
.unit[data-type="コンセプト"]{box-shadow:0 0 0 2px #7e9bff inset}
.unit[data-type="サイエンス"]{box-shadow:0 0 0 2px #56b2ff inset}
.unit[data-type="ヒストリー"]{box-shadow:0 0 0 2px #8090ff inset}
.unit[data-type="ヒューマン"]{box-shadow:0 0 0 2px #86a0ff inset}

/* 操作エリア */
.controls{margin-top:14px;background:#0a132e;border:1px solid var(--border);border-radius:16px;padding:12px}
.ctrlTop{display:flex;align-items:center;gap:10px;justify-content:space-between;flex-wrap:wrap}
.count{font-weight:900;font-size:18px}
.spBtn{min-width:120px}
.btnReady{animation:blink .8s infinite}
.rps{margin-top:10px;display:flex;gap:14px;justify-content:center;flex-wrap:wrap}
.rps .big{width:120px;height:120px;border-radius:50%;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:42px;border:none;cursor:pointer;font-weight:800}
.rps small{font-size:13px;margin-top:2px}
.big.g{background:linear-gradient(180deg,#ffb1b1,#ff8a8a)}
.big.p{background:linear-gradient(180deg,#aef5c6,#78e8a3)}
.big.c{background:linear-gradient(180deg,#c9d8ff,#a8bdff)}
.big.sw{background:#f8a98b;border-radius:14px;width:auto;height:auto;padding:12px 18px;border:none}

/* トースト（控え領域を撤去した分、底上げ） */
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:20vh;background:var(--toast);color:var(--toastText);
  border:1px solid #20335c;border-radius:12px;padding:14px 16px;opacity:0;pointer-events:none;transition:opacity .2s,transform .2s;
  z-index:40;max-width:min(90vw,720px)}
.toast.show{opacity:1;transform:translateX(-50%) translateY(-6px)}

/* モーダル（交代） */
.modal{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:50}
.win{background:#0e1736;border:1px solid var(--border);border-radius:14px;padding:14px;max-width:560px;width:92vw}
.benchList{display:flex;gap:10px;flex-wrap:wrap;margin:8px 0}
.benchItem{padding:10px 12px;border-radius:12px;border:1px solid var(--border);background:#0b1330;cursor:pointer}
.benchItem.rec{outline:2px solid var(--ok)}
.benchItem.disabled{opacity:.5;cursor:not-allowed}

/* 攻撃の揺れ */
.shake{animation:shake .5s}
@keyframes shake{
  0%,100%{transform:translateX(0)}
  20%{transform:translateX(-6px)}40%{transform:translateX(6px)}60%{transform:translateX(-4px)}80%{transform:translateX(4px)}
}

/* デバッグ行  */
.diag{margin-top:8px;color:#a7b3ff;font-size:12px}
.hide{display:none}
</style>
</head>
<body>
<div class="wrap">
  <h1>対戦 v7.4.4</h1>
  <small class="head">フルスクリーン対戦 ／ 相性・タイプ色分け ／ 二段階ナレーション ／ 必殺ゲージ制御（2025-08-12仕様）</small>

  <!-- 編成 -->
  <section id="build" class="card">
    <div class="sectionTitle">チーム編成（あなた / CPU）</div>
    <div class="teamBox">
      <div>
        <h3 style="color:var(--ally)">あなた</h3>
        <div id="selsA"></div>
      </div>
      <div>
        <h3 style="color:var(--enemy)">CPU</h3>
        <div id="selsB"></div>
      </div>
    </div>
    <div style="margin-top:10px;display:flex;gap:10px;align-items:center">
      <button id="btnRand" class="btn btnGhost">ランダムでチームを編成</button>
      <button id="btnGo" class="btn btnPrimary">対戦開始</button>
    </div>

    <div class="six">
      <div class="sectionTitle">選択中のステータス</div>
      <div class="sixGrid">
        <div class="sixCol">
          <h4 style="color:var(--ally)">あなた</h4>
          <div id="miniA" class="mini"></div>
        </div>
        <div class="sixCol">
          <h4 style="color:var(--enemy)">CPU</h4>
          <div id="miniB" class="mini"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- バトル -->
  <section id="battle" class="card">
    <div class="topRow">
      <div id="leftCard"></div>
      <div id="rightCard"></div>
    </div>

    <div class="controls">
      <div class="ctrlTop">
        <div class="count">残り <span id="remain">15</span> 秒</div>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="btnSP" class="btn spBtn">✨ 必殺 OFF</button>
          <button id="btnSwitch" class="btn">交代</button>
        </div>
      </div>
      <div class="rps">
        <button class="big g" id="btnG">✊<small>グー</small></button>
        <button class="big p" id="btnP">🖐️<small>パー</small></button>
        <button class="big c" id="btnC">✌️<small>チョキ</small></button>
      </div>
    </div>

    <div class="diag" id="diag"></div>
  </section>
</div>

<!-- 交代モーダル -->
<div class="modal" id="dlg">
  <div class="win">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <h3 style="margin:0">交代先を選択</h3>
      <button id="dlgClose" class="btn">キャンセル</button>
    </div>
    <div class="benchList" id="benchList"></div>
  </div>
</div>

<!-- トースト -->
<div class="toast" id="toast"></div>

<script>
/* ========== データ ========== */

/* ワード（ランク／タイプ／読み／技名） */
const WORDS = [
  // S
  ["パラボラアンテナ","S","サイエンス","ぱらぼらあんてな","妨害電波"],
  ["ネスカフェアンバサダー","S","ヒューマン","ねすかふぇあんばさだー","一杯いかが"],
  // A
  ["にんじんしりしり","A","フード","にんじんしりしり","なんくるないさー"],
  ["そぼろごはん","A","フード","そぼろごはん","そぼろ乱舞"],
  ["ニシローランドゴリラ","A","アニマル","にしろーらんどごりら","マウンテンビート"],
  ["毛むくじゃら","A","アニマル","けむくじゃら","ムクジャララ"],
  ["九品仏","A","ジオ","くほんぶつ","仏の顔も三度まで"],
  ["けんちん汁","A","フード","けんちんじる","長寿の秘訣"],
  // B
  ["カムチャッカ半島","B","ジオ","かむちゃっかはんとう","言論統制"],
  ["タランチュラ","B","アニマル","たらんちゅら","言葉狩り"],
  ["ハシビロコウ","B","アニマル","はしびろこう","言論統制"],
  ["バルサミコ酢","B","フード","ばるさみこす","言論統制"],
  ["ピロリ菌","B","サイエンス","ぴろりきん","ゲシュタルト崩壊"],
  ["トリニダード・トバゴ","B","ジオ","とりにだーどとばご","言葉狩り"],
  ["カラメル色素","B","サイエンス","からめるしきそ","ゲシュタルト崩壊"],
  // C
  ["バビロン捕囚","C","ヒストリー","ばびろんほしゅう","言論統制"],
  ["鳥取砂丘","C","ジオ","とっとりさきゅう","ゲシュタルト崩壊"],
  ["プラシーボ効果","C","サイエンス","ぷらしーぼこうか","ゲシュタルト崩壊"],
  ["渡来人","C","ヒューマン","とらいじん","文字化け"],
  ["さるびあ丸","C","ジオ","さるびあまる","言葉狩り"],
  ["ペペロンチーノ","C","フード","ぺぺろんちーの","ゲシュタルト崩壊"],
  ["ポリプロピレン","C","サイエンス","ぽりぷろぴれん","言論統制"],
  ["サラエボ事件","C","ヒストリー","さらえぼじけん","言葉狩り"],
  // D
  ["クマンバチ","D","アニマル","くまんばち","言論統制"],
  ["県庁所在地","D","ジオ","けんちょうしょざいち","文字化け"],
  ["照り焼きチキン","D","フード","てりやきちきん","文字化け"],
  ["ねるねるねるね","D","フード","ねるねるねるね","ゲシュタルト崩壊"],
  ["スルメイカ","D","アニマル","するめいか","ゲシュタルト崩壊"],
  // X
  ["本質","X","コンセプト","ほんしつ","鏡文字"],
  ["見える化","X","コンセプト","みえるか","鏡文字"],
  ["自分ごと化","X","コンセプト","じぶんごとか","鏡文字"],
  ["解像度","X","コンセプト","かいぞうど","鏡文字"],
];

/* タイプ相性（円環） 1.5 / 0.67 */
const TYPE_RING = ["ヒストリー","ジオ","コンセプト","サイエンス","アニマル","ヒューマン","フード"];
const TYPE_ADV = {}; // strong/weak を作る
for(let i=0;i<TYPE_RING.length;i++){
  const me=TYPE_RING[i], fwd=TYPE_RING[(i+1)%TYPE_RING.length], bwd=TYPE_RING[(i+6)%TYPE_RING.length];
  const weak1=TYPE_RING[(i+3)%TYPE_RING.length], weak2=TYPE_RING[(i+4)%TYPE_RING.length];
  TYPE_ADV[me]={strong:[fwd,bwd], weak:[weak1,weak2]};
}

/* タイプ背景 */
const TYPE_BG = {
  "ジオ":"var(--geo)","アニマル":"var(--animal)","フード":"var(--food)",
  "コンセプト":"var(--concept)","サイエンス":"var(--science)",
  "ヒストリー":"var(--history)","ヒューマン":"var(--human)"
};

/* ========== ステ算出（仕様どおり。EffectMul/RankMulは不使用） ========== */
const P_RANK = {S:170,A:165,B:160,C:150,D:145,X:150};
const HP_BASE = {S:560,A:540,B:520,C:500,D:480,X:500};

function kanaLen(k){ return [...k].length; } // 見た目長さの近似
function hiraRatio(k){ // 全ひらがなで 1.0 になる
  const arr=[...k]; const hira=arr.filter(ch=>/[\u3041-\u3096]/.test(ch)).length;
  return arr.length? hira/arr.length : 1;
}

function computeStats(word){
  const [name,rank,type,kana,skill]=word;
  const T=kanaLen(kana);
  // 攻守配分
  const baseA=17.5, baseD=17.5;
  // 構成25%：全ひらがな → 中立12.5/12.5
  const compA=12.5, compD=12.5;
  // 音20%：簡略（中立）
  const phA=10, phD=10;
  // 長さ20%： T=5を基準
  const s_len=Math.max(-1,Math.min(1,(6-T)/6));
  const lenA=20*(0.5+0.5*s_len); const lenD=20-lenA;

  const atkPct=baseA+compA+phA+lenA;
  const defPct=baseD+compD+phD+lenD;

  const ATK = Math.round(P_RANK[rank]*atkPct/100);
  const DEF = Math.round(P_RANK[rank]*defPct/100);
  let HP = HP_BASE[rank] + 20*(T-5);

  // 回避率
  const evaBase = 10 + 8*hiraRatio(kana) - 0.5*(T-5) + ({S:-1,A:-0.5,B:0,C:0.5,D:1,X:0}[rank]);
  const EVA = Math.max(5,Math.min(35,Math.round(evaBase*10)/10));

  return {name,rank,type,kana,skill,HP,ATK,DEF,EVA};
}

const DATA = WORDS.map(computeStats);

/* ========== DOM util ========== */
const $=id=>document.getElementById(id);
const el=(tag,cls,html)=>{const e=document.createElement(tag); if(cls) e.className=cls; if(html!=null) e.innerHTML=html; return e;}
const delay=ms=>new Promise(r=>setTimeout(r,ms));

/* トースト（常に1.5秒） */
const toast=(msg)=>{
  const t=$('toast'); if(!t){alert(msg);return;}
  t.textContent=msg; t.classList.add('show');
  clearTimeout(t._h); t._h=setTimeout(()=>t.classList.remove('show'),1500);
};

/* ========== 編成UI ========== */
const NAMES=DATA.map(x=>x.name);

function optionsHtml(selected){
  return NAMES.map(n=>`<option ${n===selected?'selected':''}>${n}</option>`).join('');
}
function makeSels(side,rootId){
  const box=$(rootId); box.innerHTML='';
  for(let i=0;i<3;i++){
    const row=el('div','selRow');
    row.innerHTML=`<span>#${i+1}</span>
      <select id="${side}-${i}">${optionsHtml(NAMES[i])}</select>`;
    box.appendChild(row);
  }
}
makeSels('A','selsA'); makeSels('B','selsB');

function getSelTeam(side){
  return [0,1,2].map(i=>$(`${side}-${i}`).value);
}

function syncDisable(side){
  const used=new Set(); for(let i=0;i<3;i++) used.add($(`${side}-${i}`).value);
  for(let i=0;i<3;i++){
    const sel=$(`${side}-${i}`);
    [...sel.options].forEach(o=>{ o.disabled = used.has(o.value) && o.value!==sel.value; });
  }
}

function miniHtml(side){
  const names=getSelTeam(side);
  return names.map(n=>{
    const u=DATA.find(x=>x.name===n);
    return `
    <div class="unit ${side==='A'?'ally':'enemy'}" data-type="${u.type}" style="background:${TYPE_BG[u.type]}">
      <header><div>${u.name} <span class="badge">${u.type}</span></div></header>
      <div class="stats">
        ${statRow('HP',u.HP,800)}
        ${statRow('攻撃',u.ATK,120)}
        ${statRow('防御',u.DEF,120)}
        ${statRow('回避',u.EVA,20)}
      </div>
    </div>`;
  }).join('');
}

function statRow(label,val,max){
  const pct=Math.max(0,Math.min(100,Math.round(100*val/max)));
  return `<div class="stat"><div style="width:48px">${label}</div>
    <div class="sbar"><div class="sfill" style="width:${pct}%"></div></div>
    <div style="width:72px;text-align:right">${val}</div></div>`;
}

function renderMini(side){ $(side==='A'?'miniA':'miniB').innerHTML=miniHtml(side); }
['A','B'].forEach(s=>{
  for(let i=0;i<3;i++){
    $(`${s}-${i}`).addEventListener('change',()=>{ renderMini(s); syncDisable(s); });
  }
});
renderMini('A'); renderMini('B'); syncDisable('A'); syncDisable('B');

$('btnRand').addEventListener('click',()=>{
  const pick=()=>([...NAMES].sort(()=>Math.random()-0.5).slice(0,3));
  const a=pick(), b=pick();
  a.forEach((n,i)=>$(`A-${i}`).value=n);
  b.forEach((n,i)=>$(`B-${i}`).value=n);
  renderMini('A'); renderMini('B'); syncDisable('A'); syncDisable('B');
});

/* ========== バトル ========== */
let state=null;

function buildFighter(name){
  const base=DATA.find(x=>x.name===name);
  return {
    ...structuredClone(base),
    hp:base.HP, sp:0,
    skipT:0, gestaltT:0, doomT:0, noswitchT:0,
    atkMul:1, atkMulT:0, evaOverride:null, evaT:0,
    endure:false
  };
}
function teamFromNames(names){ return names.map(buildFighter); }

function left(){ return state.A.team[state.A.i]; }
function right(){ return state.B.team[state.B.i]; }

function typeMult(attType, defType){
  const info=TYPE_ADV[attType]||{strong:[],weak:[]};
  if(info.strong.includes(defType)) return 1.5;
  if(info.weak.includes(defType)) return 0.67;
  return 1;
}

function hpPct(u){ return Math.max(0,Math.min(100,Math.round(100*u.hp/u.HP))); }

function unitHtml(u,role){
  return `
  <div class="unit ${role}" data-type="${u.type}" style="background:${TYPE_BG[u.type]}" id="card-${role}">
    <header>
      <div>${u.name} <span class="badge">${u.type}</span></div>
      <div class="badge">HP <span id="hpnum-${role}">${Math.max(0,Math.round(u.hp))}/${u.HP}</span></div>
    </header>
    <div class="hpRow">
      <div class="gauge">
        ${[0,1,2,3,4,5].map(i=>`<div class="dot ${i<u.sp?'on':''}" id="sp-${role}-${i}"></div>`).join('')}
      </div>
      <div class="hpBar"><div class="hpFill" id="hpbar-${role}" style="width:${hpPct(u)}%"></div></div>
      <div class="hpNum"></div>
    </div>

    <div class="box">
      <div class="skillName">✨ 必殺：${u.skill}</div>
      <div id="skdesc-${role}" style="margin-top:6px;font-size:13px;color:var(--muted)">${skillDesc(u)}</div>
    </div>

    <div class="box">
      <div class="typeRow"><span class="badge">相性</span>
        <span id="aff-${role}">x1.00（等倍）</span>
      </div>
    </div>

    <div class="box">
      <h5>基礎ステータス</h5>
      <div class="stats">
        ${statRow('HP',u.HP,800)}
        ${statRow('攻撃',u.ATK,120)}
        ${statRow('防御',u.DEF,120)}
        ${statRow('回避',u.EVA,20)}
      </div>
    </div>
  </div>`;
}

function renderSides(){
  $('leftCard').innerHTML=unitHtml(left(),'ally');
  $('rightCard').innerHTML=unitHtml(right(),'enemy');
  updateAff();
  updateSPBtn();
}

function updateAff(){
  const lm=typeMult(left().type,right().type);
  const rm=typeMult(right().type,left().type);
  $('aff-ally').textContent = `x${lm.toFixed(2)}（${lm>1?'抜群':lm<1?'いまいち':'等倍'}）`;
  $('aff-enemy').textContent = `x${rm.toFixed(2)}（${rm>1?'抜群':rm<1?'いまいち':'等倍'}）`;
}

function updateHP(role,u){
  $('hpbar-'+role).style.width = hpPct(u)+'%';
  $('hpnum-'+role).textContent = `${Math.max(0,Math.round(u.hp))}/${u.HP}`;
}

function updateSPBtn(){
  const readyA = state.A.team[state.A.i].sp>=6;
  const readyB = state.B.team[state.B.i].sp>=6;
  const btn=$('btnSP');
  btn.disabled=!readyA;
  btn.classList.toggle('on',state.spOn);
  btn.classList.toggle('btnReady',readyA&&!state.spOn);
  btn.textContent = state.spOn ? '✨ 必殺 ON' : '✨ 必殺 OFF';
  for(let i=0;i<6;i++){
    $('sp-ally-'+i)?.classList.toggle('on',i<left().sp);
    $('sp-enemy-'+i)?.classList.toggle('on',i<right().sp);
  }
  $('leftCard').classList.toggle('readyPulse',readyA&&!state.spOn);
  $('rightCard').classList.toggle('readyPulse',readyB);
  if(readyA && !state.spAnnA){ toast('あなたの必殺ゲージが満タン！'); state.spAnnA=true; }
  if(readyB && !state.spAnnB){ toast('相手の必殺ゲージが満タン！'); state.spAnnB=true; }
}

/* 必殺テキスト */
function skillDesc(u){
  const n=u.name, r=u.rank, s=u.skill;
  const map={
    "妨害電波":"攻撃2.5倍＋相手の必殺ゲージを0に。",
    "一杯いかが":"通常攻撃＋味方全員のHPを60回復。",
    "なんくるないさー":"攻撃1.5倍。次の被弾で致死でもHP1で耐える（1回）。",
    "そぼろ乱舞":"3連撃（0.75→0.50→0.25）。途中で倒しても次の敵に続行。",
    "マウンテンビート":"この攻撃1.5倍。以降2Tは攻撃1.3倍が継続。",
    "ムクジャララ":"攻撃1.4倍＋回避率60%（3T）。",
    "仏の顔も三度まで":"攻撃1.6倍＋被ダメ半減（3T）。",
    "長寿の秘訣":"攻撃1.2倍＋HP150回復。",
    "鏡文字":"相手の誰かの必殺をコピーして2倍で放つ。",
    "言葉狩り":"相手を1T行動不可。",
    "言論統制":"相手を4T交代不可。",
    "ゲシュタルト崩壊":"相手に4T付与。攻撃時33%で自傷100。",
    "文字化け":"3T後に戦闘不能（交代で解除）。"
  };
  return map[s]||"";
}

/* 交代モーダル */
function openSwitch(){
  const list=$('benchList'); list.innerHTML='';
  const me=state.A, opp=state.B;
  const cand=[0,1,2].filter(i=>i!==me.i && me.team[i].hp>0);
  if(!cand.length){ toast('控えがいません'); return; }
  cand.forEach(i=>{
    const u=me.team[i];
    const rec = typeMult(u.type, opp.team[opp.i].type)>1;
    const item=el('div','benchItem'+(rec?' rec':''),`${u.name} <span class="badge">${u.type}</span>`);
    item.onclick=()=>{ me.i=i; clearFlags(me.team[i]); toast(`いけ、${u.name}！`); $('dlg').style.display='none'; renderSides(); };
    list.appendChild(item);
  });
  $('dlg').style.display='flex';
}
$('btnSwitch').onclick=openSwitch;
$('dlgClose').onclick=()=>$('dlg').style.display='none';

/* 状態初期化 */
function clearFlags(u){
  u.skipT=0; u.gestaltT=0; u.doomT=0; u.noswitchT=0; u.atkMul=1; u.atkMulT=0; u.evaOverride=null; u.evaT=0; u.endure=false; u.sp=0;
}

/* バトル開始 */
$('btnGo').addEventListener('click',()=>{
  state={
    A:{team:teamFromNames(getSelTeam('A')), i:0},
    B:{team:teamFromNames(getSelTeam('B')), i:0},
    spOn:false, spAnnA:false, spAnnB:false, busy:false, remain:15, _timer:null
  };
  $('build').style.display='none';
  $('battle').style.display='block';
  toast(`いけ、${left().name}！バトルスタート！`);
  renderSides(); startRound();
});

/* 1ターン進行 */
function startRound(){
  clearInterval(state._timer);
  state.remain=15; $('remain').textContent=state.remain;
  state._timer=setInterval(()=>{
    state.remain--; $('remain').textContent=state.remain;
    if(state.remain<=0){
      if(forceSwitchIfKO()) { startRound(); return; }
      const r=['G','P','C'][Math.floor(Math.random()*3)];
      pick(r);
    }
  },1000);
}

function stopRound(){ clearInterval(state._timer); }

/* 入力 */
$('btnG').onclick=()=>pick('G');
$('btnP').onclick=()=>pick('P');
$('btnC').onclick=()=>pick('C');
$('btnSP').onclick=()=>{ if(left().sp>=6){ state.spOn=!state.spOn; updateSPBtn(); } };

function forceSwitchIfKO(){
  if(left().hp>0) return false;
  const alive=[0,1,2].filter(i=>i!==state.A.i && state.A.team[i].hp>0);
  if(!alive.length) return false;
  state.A.i = alive[Math.floor(Math.random()*alive.length)];
  clearFlags(left());
  toast(`いけ、${left().name}！`);
  renderSides();
  return true;
}

/* CPU 手（単純：ランダム＋満タンなら必殺ON） */
function cpuChoice(){
  if(right().sp>=6) state.cpuSP=true; else state.cpuSP=false;
  return ['G','P','C'][Math.floor(Math.random()*3)];
}

function rpsResult(me,cpu){
  if(me===cpu) return 0;
  const win = (me==='G'&&cpu==='C')||(me==='C'&&cpu==='P')||(me==='P'&&cpu==='G');
  return win?1:-1;
}

/* ダメージ計算 */
function baseDamage(att,def){
  let dmg = 100 * (1+att.ATK/100) / (1+def.DEF/120);
  dmg *= att.atkMul;
  dmg *= typeMult(att.type,def.type);
  // 20%幸運±20%
  const r=Math.random();
  if(r<0.2) dmg*=1.2; else if(r<0.4) dmg*=0.8;
  if(def.halfT>0) dmg*=0.5;
  return Math.max(0,Math.round(dmg));
}

async function pick(meHand){
  if(state.busy) return;
  state.busy=true; stopRound();

  // あいこでもゲージ+1、50%で+1（期待+1.5）
  [left(),right()].forEach(u=>{
    u.sp += 1 + (Math.random()<0.5?1:0);
    if(u.sp>6) u.sp=6;
  });
  updateSPBtn();

  const cpuHand = cpuChoice();
  const res=rpsResult(meHand,cpuHand);
  toast(`あなたは${handName(meHand)}。相手は${handName(cpuHand)}。`); await delay(900);
  toast(res>0?'あなたの勝ち。': res<0?'相手の勝ち。':'あいこ。'); await delay(900);

  if(res===0){ // あいこ：効果ターンは減る（1ターン経過）
    endOfTurn(left(),true); endOfTurn(right(),true);
    updateSPBtn(); state.busy=false; startRound(); return;
  }

  const actor = res>0? left() : right();
  const target = res>0? right() : left();
  const aRole = res>0? 'ally':'enemy';
  const dRole = res>0? 'enemy':'ally';

  const useSP = res>0? state.spOn && actor.sp>=6 : state.cpuSP && actor.sp>=6;

  if(actor.skipT>0){ // 行動不可
    toast(`${actor.name}は動けない！`); await delay(900);
  }else{
    // 必殺前処理（宣言はじゃんけん前だけど、演出はここ）
    if(useSP){
      await doSpecial(actor,target,res>0);
      actor.sp=0; updateSPBtn();
    }

    // ゲシュタルト自傷
    if(actor.gestaltT>0 && Math.random()<1/3){
      toast(`${actor.name}は混乱！自傷100。`); await delay(900);
      actor.hp -= 100 * (actor.halfT>0?0.5:1);
      if(actor.hp<=0 && actor.endure){ actor.hp=1; actor.endure=false; }
      updateHP(aRole,actor);
    }else{
      // 攻撃
      const card=$('card-'+dRole);
      card.classList.add('shake'); setTimeout(()=>card.classList.remove('shake'),500);

      let dmg = baseDamage(actor,target);
      // 命中（必殺は回避不可）
      if(!useSP && Math.random()<target.EVA/100){
        toast(`${target.name}はうまく避けた！`); await delay(900);
      }else{
        // ダメージ適用（相性コメント）
        const tm=typeMult(actor.type,target.type);
        toast(`${actor.name}の攻撃！${tm>1?'相性抜群！':tm<1?'相性はいまいち…':''}`); await delay(900);

        // そぼろ乱舞
        if(useSP && actor.skill==='そぼろ乱舞'){
          const seq=[0.75,0.5,0.25];
          for(const m of seq){
            let d=Math.round(dmg*m);
            await applyDamage(target,d,dRole);
            if(target.hp<=0) break;
          }
        }else{
          await applyDamage(target,dmg,dRole);
        }
      }
    }
  }

  // 撃破？
  if(target.hp<=0){
    toast(`${target.name}は倒れた！`); await delay(900);
    const side = res>0? 'B' : 'A';
    const tm = state[side].team;
    const alive=[0,1,2].filter(i=>tm[i].hp>0);
    if(!alive.length){ toast(res>0?'勝利！':'敗北…'); return; }
    // 相手はタイプ有利を優先
    const meType = (res>0?left():right()).type;
    const best = alive.sort((i,j)=>{
      const mi=typeMult(tm[i].type, meType), mj=typeMult(tm[j].type, meType);
      return mj-mi;
    })[0];
    state[side].i=best; clearFlags(state[side].team[best]);
    toast(`${res>0?'相手':'あなた'}は${tm[best].name}をくりだした！`); await delay(900);
    renderSides();
  }

  // 自動でターン消化
  endOfTurn(left()); endOfTurn(right());
  updateSPBtn(); renderSides();
  state.busy=false; startRound();
}

function handName(h){ return h==='G'?'グー':h==='P'?'パー':'チョキ'; }

async function applyDamage(def,dmg,role){
  if(def.endure && def.hp-dmg<=0){ def.hp=1; def.endure=false; }
  else def.hp=Math.max(0,def.hp-dmg);
  $('hpbar-'+role).style.width=hpPct(def)+'%';
  $('hpnum-'+role).textContent=`${Math.max(0,Math.round(def.hp))}/${def.HP}`;
  await delay(500);
}

/* 必殺の本体（演出→効果） */
async function doSpecial(att,def,isPlayer){
  // 技名 → 効果
  if(att.rank==='X'){ // 鏡文字
    const pool=state.B.team.filter(u=>u.hp>0 && u.rank!=='X');
    if(pool.length){
      const src=pool[Math.floor(Math.random()*pool.length)];
      toast(`${att.name}の必殺、「鏡文字」！ ${src.name}の「${src.skill}」をコピー！`); await delay(900);
      toast(skillDesc(src)); await delay(900);
    }
  }else{
    toast(`${att.name}の必殺、「${att.skill}」！`); await delay(900);
    toast(skillDesc(att)); await delay(900);
  }

  // 効果
  const mul = att.rank==='X' ? 2.0 :
              att.skill==='妨害電波'? 2.5 :
              att.skill==='なんくるないさー'? 1.5 :
              att.skill==='マウンテンビート'? 1.5 :
              att.skill==='ムクジャララ'? 1.4 :
              att.skill==='仏の顔も三度まで'? 1.6 :
              att.skill==='長寿の秘訣'? 1.2 :
              att.skill==='そぼろ乱舞'? 1.0 :
              1.6; // その他（使わない）

  // S/A：バフ/攻撃/回復
  if(att.rank==='S'||att.rank==='A'||att.rank==='X'){
    if(att.skill==='一杯いかが'){
      // 通常攻撃＋全体60回復
      const d=baseDamage(att,def);
      await applyDamage(def,d,'enemy');
      state.A.team.forEach(x=>x.hp=Math.min(x.HP,x.hp+60));
      toast(`味方のHPが回復！`); await delay(900);
    }else if(att.skill==='長寿の秘訣'){
      att.atkMul*=mul; att.hp=Math.min(att.HP,att.hp+150);
    }else if(att.skill==='ムクジャララ'){
      att.atkMul*=mul; att.evaOverride=60; att.evaT=3;
    }else if(att.skill==='仏の顔も三度まで'){
      att.atkMul*=mul; att.halfT=3;
    }else if(att.skill==='なんくるないさー'){
      att.atkMul*=mul; att.endure=true;
    }else if(att.skill==='マウンテンビート'){
      att.atkMul*=mul; att.atkMulT=2; // 次2T 1.3倍の扱いは endOfTurn で
    }else if(att.skill==='そぼろ乱舞'){
      // ダメージ処理は攻撃時に
    }else if(att.skill==='妨害電波'){
      att.atkMul*=mul; def.sp=0; updateSPBtn();
    }else if(att.rank==='X'){
      // ダメージ倍率は baseDamage 時に 2倍加算済み扱いにしないのでここで一時増幅
      att.atkMul*=2.0; att._xOnce=true; // このターンのみ
    }
  }else{
    // B〜D：状態異常
    if(att.skill==='言葉狩り'){ def.skipT=Math.max(def.skipT,1); }
    if(att.skill==='言論統制'){ def.noswitchT=Math.max(def.noswitchT,4); }
    if(att.skill==='ゲシュタルト崩壊'){ def.gestaltT=Math.max(def.gestaltT,4); }
    if(att.skill==='文字化け'){ def.doomT=Math.max(def.doomT,3); }
  }
}

/* ターン終了で持続を処理（じゃんけん1回＝1ターン） */
function endOfTurn(u,aiko=false){
  if(u.atkMulT>0){ // ゴリラ
    u.atkMulT--; u.atkMul = u.atkMulT>0 ? 1.3 : 1.0;
  }
  if(u.evaT>0){ u.evaT--; if(u.evaT<=0) u.evaOverride=null; }
  if(u.halfT>0){ u.halfT--; }
  if(u.skipT>0){ u.skipT--; }
  if(u.gestaltT>0){ u.gestaltT--; }
  if(u.noswitchT>0){ u.noswitchT--; }
  if(u.doomT>0){ u.doomT--; if(u.doomT===0) u.hp=0; }
  if(u._xOnce){ u._xOnce=false; u.atkMul=1.0; }
}

/* ========== 画面遷移・初期UI ========== */
function diag(msg){
  $('diag').textContent=msg;
}
diag('JS: OK / UI: OK / Bind: OK');
</script>
</body>
</html>
